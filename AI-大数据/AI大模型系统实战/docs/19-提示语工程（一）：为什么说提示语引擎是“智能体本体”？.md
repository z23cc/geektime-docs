你好，我是 Tyler。

在上节课中我们学习了 AIGC 系统策略建模的方法。接下来我们会深入学习AIGC系统各模块的知识。我们先从提示语工程开始学起。

之前我也说过，提示引擎在一定程度上就是“智能体的本体”，所以它的重要性不言而喻。拿建筑行业做比方，提示引擎（prompt engine）是一个功能完备、拎包入住的成品房，而提示语工程（prompt engineering）就是搭建这个房子的设计图纸和施工手册。

为了让你全面系统地学习这部分知识，我安排了四节课做讲解。今天我们的学习重点是熟悉提示语工程的主要概念和设计方法。

## 提示语工程概念

上节课你已经学习了提示语引擎是专门服务于生成式 AI 模型的系统模块，它需要具备各类知识表达和知识检索的能力，识别用户意图、选择检索结果，并且进行有效的信息压缩。而这些任务都需要精心设计的提示语工程来完成。

而在学习提示语工程设计之前，我们需要搞清楚提示语工程中的主要概念。

### 上下文学习（In-Context Learning，ICL）

首先，让我们来谈谈上下文学习的概念，这是提示语工程诞生的基础。在GPT-3的[那节课](https://time.geekbang.org/column/article/700557)里，我们学习到了OpenAI提出的一个更新的理念，即“上下文学习（In-Context Learning）”。这个能力允许我们在提示语中提供示例样本，以帮助模型理解要解决的任务的特点。

这种不需要模型微调，直接将知识通过提示词注入模型的方法也引出了全新的“少样本学习（Few-Shot Learning）”的概念。

与传统的模型微调中的“少样本学习”不同，GPT-3提出的少样本学习允许下游用户直接通过提示词（prompt）将任务示例样本输入到模型中，从而使模型在提示语中学习新样本的模式和规律。

根据提供的示例样本数量，提示语工程可以分为“零样本学习（Zero-Shot Learning）”和“少样本学习（Few-Shot Learning）”。

零样本学习就是直接将模型需要处理的任务，通过提示语提供给模型，并要求模型输出结果。而少样本学习则会为模型提供例子，具体就是一组在目标任务上的高质量示例，通常每个示例都包括一组目标的输入和输出。

在AIGC系统中，如果你的提示引擎直接将用户输入的问题传递给LLM，那用的就是 Zero-Shot 的处理方法。最早期的ChatGPT采用了这种方法，它会直接将用户的输入内容“透传”给大型语言模型。

不过在早期的这种“简陋”的使用条件下，一些对提示语工程有所了解的用户也会在问题前为大语言模型提供一些示例，手动把它变成 Few-Shot 提示语。

然而，这时用户只能基于自己的使用经验来选择更合适的提示词，但这种靠猜测试探的方式升高了大语言模型的使用门槛。

因此，大模型系统会根据不同用户的使用记录，自行判断哪类提示词对自家模型更友好。在提示与长度限制相对宽松的情况下，系统还会自动使用Few-Shot的形式帮助用户使用更加友好的提示词来优化提示语质量。

我们稍微总结一下，提示语工程的核心目标是，基于ICL的特点为LLM选择适当的Few-Shot示例样本。

### 指令微调

指令微调是我们之前课程里学习的一项技术，它与ICL不同，是通过模型微调将用户在平台中的历史问答的信息，直接“固化”到模型的参数中的一种方法。

然而，从提示语工程的角度来看，指令微调更多是让模型理解该如何与外部世界对话。狭义上，这个外部世界是用户的对话输入。但从广义上讲，经过提示语引擎加工后的数据，也是外部世界的对话内容。因此，在对模型进行指令微调时，我们需要考虑到用户问答输入的分布以及提示语引擎处理后数据内容的分布的区别，这可能会引入新的问题。

由于指令微调不是这节课的重点，我会在大模型训练那节课带你详细学习这个内容。

## 提示语工程设计

理解了前面的概念，你应该已经意识到了，提示语工程最重要的是后面这两个问题。

1. 为模型提供外部知识，也就是通过示例样本来进行少样本学习（Few-Shot Learning）。
2. 让模型理解指令任务，通过提示语策略，帮助模型解决复杂问题。

我们先来讨论第一个问题，那就是如何为模型提供有效的示例样本。在术语上的说法则是优选（Selecting）。

### 优选（Selecting）

为模型优选示例样本的过程，其实就是围绕着用户输入的问题，为模型收集高质量数据的过程。你可以试着回想一下，在AIRC系统中你是如何收集高质量数据的呢？

没错，是通过召回和排序完成的，其中召回过程需要使用向量引擎，内容标签倒排索引和知识图谱等知识表达和知识检索方法。

其实在提示引擎中我们第一步要做的工作就是围绕用户的需求，去检索这些最重要的外部数据。这个检索和你之前学过的AIRC系统中的知识是一模一样的。

你同样需要将最优质的内容排在前面，因为大模型所能接受的 prompt 是有限的，你只能在海量的内容中优选最重要的内容，来作为提示词的一部分。具体怎么排序我们接着往下看。

### 排序（Ordering）

在选择最合适的提示样本后，我们需要进一步对其进行二次加工，这个加工过程是AIGC系统独有的“重排”模块，用于优化提示的内容。

因为业界的实践表明，在某些测试中，不同排序的示例可能导致生成内容的质量大幅波动。因此，除了示例样本的选取之外，示例的排序也会影响提示工程的有效性。

目前，主要有一种常见的工业界使用的排序策略，也是最低成本的策略，那就是基于示例质量的排序，这个方法非常直接，只需要将质量较高的示例样本排在后面，以靠近问题输入的位置。除此之外，还有一些相对复杂的基于熵的排序方法，这个我们将在下节课进行学习。

### 可信AI（Trustworthy AI）

之前说过，提示语引擎其实一定程度上就是智能体的“本体”。所以LLM的输入，也就是提示词，以及输出也就是生成内容都需要由提示语引擎来负责。因此，现在工业界在AIGC系统的链路就是：检索 -&gt; 生成 -&gt; 检索的形态。你可能会问了，检索到生成的这个过程我倒是理解，可是为什么生成后面还会再加一个检索呢？

很好的问题，这是因为两次检索的目标是不同的。第一次检索的输入是用户问题，目的是为大语言模型提供外部记忆；而第二次检索的输入则是生成内容，目的是为生成的内容提供引用信息，增加生成内容的可信度，此外，我们还可以通过这次检索，来优选生成模型输出的多个结果。

### 推理步骤（Reasoning Steps）

现在，你已经知道了该如何为大语言模型提供有效的示例样本。接下来，我们再来聊聊怎样通过提示语策略，帮助模型解决复杂问题。我们将用一些思维链方法帮助模型把大事化小。

首先，让我们回顾一下思维链（Chain-of-Thought，CoT）的概念。CoT是一种用于引导大语言模型进行推理的方法。CoT通过提示词指示模型，生成一系列简短的句子来给出推理步骤。

在[第16节课](https://time.geekbang.org/column/article/701454)中我们学习过，工业界在实践中发现，经过代码语料训练过的LLM具有更强的 CoT 能力。在[第17节课](https://time.geekbang.org/column/article/701952)，也就是“涌现”原理的那节课里我们也提过，CoT 的优势在复杂的推理任务更明显，在使用大参数模型（比如 50B以上的模型）时，这个优势则更明显。

CoT 提示可以约束大语言模型理解和遵循推理逻辑，从而提高推理任务的准确性。虽然 CoT 可以用一些动态的步骤生成答案，但是还是存在一些局限性。这就催生出了很多方法来优化 CoT 的过程，比如我们下节课马上要学习的自一致采样（Self-Consistency Sampling）。

## 总结

好的，我们来做个总结吧。

今天，我们一起深入学习了 ICL 的核心理念，还有由 ICL 能力而衍生出的、提示语工程的众多特性。你不仅学到了怎么利用已经学习过的 AIRC 知识来优选示例样本，还学习了一些对示例样本排序的新方法。

这节课的重点就是如何提升大模型的回复质量。首先我们要构建一个基于二次检索的记忆增强和可信AI策略。其次，就是利用思维链的能力，通过推理策略来协助模型解决复杂问题。

![](https://static001.geekbang.org/resource/image/d4/a9/d48452e6ffb86cf0f8c22e2730d9c8a9.png?wh=1906x778)

提示语工程这几节课的内容高度相关，所以希望你能好好学习消化今天学到的内容。下一节课，我们将会继续深入学习提示引擎的相关能力，敬请期待！

## 思考题

很多人认为提示语工程只是自说自话的试错游戏，你觉得他说的对吗？给出你认为正确或错误的原因。

恭喜完成我们第 19 次打卡学习，期待你在留言区和我交流互动。如果你觉得有收获，也欢迎你分享给你身边的朋友，邀 TA 一起讨论。
<div><strong>精选留言（8）</strong></div><ul>
<li><span>一只豆</span> 👍（6） 💬（1）<p>提示语工程的本质，还是（领域）知识注入。好的提示词工程如果没有富含增量信息的知识作为外部记忆注入，如果没有提供与增量信息相匹配的推理逻辑，那就是没有注入知识。那就是一个死循环，或者说瞎尝试。面对 AI，拼的还是人类自身的知识&#47;经验的积累+对 LLM 的 ICL 特点的深刻理解。
老师攒了几个星期的内功，循循善诱到这个板块，终于排山倒海的开始降龙十八掌了。。。。。帅且飒！！</p>2023-09-22</li><br/><li><span>王平</span> 👍（2） 💬（1）<p>请问这里提到的为模型提供外部知识，和 RAG 是一回事吗？</p>2023-12-12</li><br/><li><span>Eric</span> 👍（2） 💬（1）<p>您好，请问基于零样本和基于少样本的提示词方式差别大吗? 目前接触到的公司自研的大语言模型以及百度千帆大模型，都是不支持使用少样本的方式来传递prompt，只支持直接把prompt通过问题给到模型。</p>2023-11-10</li><br/><li><span>l_j_dota_1111</span> 👍（1） 💬（2）<p>老师你好，这个优选的目的我还是没太理解。是不是说当用户输入prompt，后台拿到钱prompt 后，并没有直接传给大模型，而是根据prompt进行相关内容的筛选，并形成优秀示例，然后和用户输入的内容一起组织成新的prompt发送给大模型？</p>2024-02-01</li><br/><li><span>顾琪瑶</span> 👍（1） 💬（1）<p>提示语的质量该如何衡量呢？
提示语的召回（检索）简单理解是不是通过用户的输入去向量数据库检索相似度最高的几个提示语呢？</p>2023-09-22</li><br/><li><span>周晓英</span> 👍（4） 💬（1）<p>提示语工程（Prompt Engineering）指的是为了使模型生成特定的输出而设计和优化输入提示的过程。在一些情况下，它可能看起来像是一个试错的游戏，因为工程师可能需要通过多次尝试来找到能够产生所需输出的正确提示。然而，提示语工程实际上是一种更复杂、更系统的过程，具有一定的技术和理论基础。以下是一些考虑点：

基于理论和经验:

提示语工程通常不是随机的。它通常基于对模型的理解，以及对特定任务和领域的知识。通过理解模型的工作方式和可能的局限性，工程师可以更有效地设计提示。
系统化和方法论:

提示语工程可以是一个系统化的过程，其中包括了测试、评估、和迭代。它可能包括了设计实验，收集和分析数据，以及使用统计和机器学习技术来优化提示。
数据驱动:

在很多情况下，提示语工程可以是数据驱动的。例如，可以通过分析模型在不同提示下的表现，或者收集用户或专家的反馈，来持续优化提示。
创造性:

提示语工程也需要一定的创造性和洞察力。通过理解任务的需求和模型的行为，工程师可以设计出能够引导模型生成有用输出的创新提示。
可扩展性和通用性:

高效的提示语工程应考虑到可扩展性和通用性，以使得找到的解决方案不仅仅是针对单一问题的，而是能够广泛应用于类似的任务和问题。
与模型训练和微调结合:

提示语工程通常不是孤立的。它可以与模型训练和微调相结合，以实现最优的性能。</p>2023-10-02</li><br/><li><span>姚俊</span> 👍（1） 💬（0）<p>对于没有语法，只有语义的自然语言，提示词要工程化，个人认为还有很长的路要探索</p>2024-01-26</li><br/><li><span>aLong</span> 👍（1） 💬（0）<p>我认为不是自说自话的游戏。这个提示语工程也是需要有一套规则吧。按照提示语给出的目的测试是否反馈信息符合要求。并且需要通过多测试和调整等工作去完善。并且我感觉在使用GPT的web页面时候他肯定会对我的提示语加以调整和优化工作。不然很难给出我认为不错的内容。

我现在感觉虽然提示语工程是有必要的，但对于不同的大语言模型有个问题那就是不同大模型都需要去针对调整有点压力和棘手。</p>2024-01-25</li><br/>
</ul>