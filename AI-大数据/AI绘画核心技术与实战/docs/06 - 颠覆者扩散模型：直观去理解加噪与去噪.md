你好，我是南柯。

上一讲我们结识了旧画师GAN，提到了扩散模型在内容精致度、风格多样性和通用编辑等能力上弥补了GAN的不足之处。如果说GAN是旧画师，扩散模型无疑就是当下最受追捧的新画师。DALL-E 2、Imagen、Stable Diffusion这些大名鼎鼎的模型，它们背后的魔术师都是扩散模型。

用过Midjourney的同学也许都注意过这样的现象，随着图像生成的进度条推进，图像也是从模糊到清晰。你可以点开下面的图片查看这个过程。

![](https://static001.geekbang.org/resource/image/40/4d/403f88e39646693d91080699af3ac84d.jpg?wh=4409x1240)

聪明的你应该猜到了，这背后的技巧大概率也是扩散模型！之所以说大概，是因为Midjourney并没有对外公布其背后的算法原理，后面我们会用专门的一讲带你推测Midjourney背后的技术方案，这里先卖个关子。

那么，扩散模型的工作原理是怎样的呢？算法优化目标是什么？与GAN相比有哪些异同？这一讲我们便从这些基础问题出发，开始今天的扩散模型学习之旅。

## 初识扩散模型

扩散模型的灵感源自热力学。我们可以想象一下这样的过程，朝着一杯清水中滴入一滴有色碘伏，然后观察这杯水。

你会发现，碘伏在水中会有一个扩散的过程，最终完全在水中呈现出均匀的状态。扩散效应代表从有序到混乱的过程。比如下面这张图，把一滴红色的液体滴入清水中，颜色会逐渐扩散开，最终整杯水都变为红色。

![](https://static001.geekbang.org/resource/image/b9/bf/b9a441bdc01880f9fa52b70f7cfe1fbf.jpg?wh=4409x2480)

AI绘画中的扩散模型和上面的例子类似，对于一张图片，逐渐加入噪声，最终图像将变成一张均匀的噪声图。我在下面放了一张图例，展示了这个过程。

![](https://static001.geekbang.org/resource/image/63/c4/63e3c220ab0c9cff5f2f525e0cb422c4.jpg?wh=4409x1688)

如果把这个过程反过来，从一个随机噪声图出发，逐步去除噪声，可以生成一张高质量的图片，这便达成了AI绘画的目的。**基于扩散模型实现AI绘画的精髓就在于，如何实现这个逐步去除噪声的过程**。在每一步的去噪过程中，起作用的是一个需要训练的神经网络，也就是一个UNet。UNet的细节我们下一讲再展开，这里你可以先把它当成一个黑盒子。

![](https://static001.geekbang.org/resource/image/66/b1/6624807c268f8a1d76e0ccc0b17c09b1.jpg?wh=4409x1617)

从上面的过程我们可以知道，基于扩散模型实现AI绘画包括两个过程——加噪过程和去噪过程。

无论是把一张图片加噪到纯噪声（即全是噪点的图片），还是把纯噪声做去噪处理，生成一张干净的图片，都需要多次操作。为了衡量转化过程到底需要多少步操作，就要引入一个时间步t的概念。t的取值为1-1000中的一个整数，代表加噪声的步数。

实验中整个加噪过程中需要1000次加噪操作。直觉上，从纯噪声去噪得到图像也需要1000次去噪操作来完成。不过，实际使用中，通过数学推导的方式可以证明并不需要1000步，比如我们第1讲中用到的Eular采样器，只需要20~30步去噪，便可以从纯噪声去噪得到清晰的图片。

对于Diffusion模型的加噪过程，每一步加噪依赖于时间步t。t越接近0，当前加噪结果越靠近原始图像；t越接近1000，当前加噪结果越靠近纯噪声。

![](https://static001.geekbang.org/resource/image/5d/e7/5d7d09834f4215fd6e6bf1d2917641e7.jpg?wh=4409x1122)

当我们通过训练得到神经网络UNet后，从原始噪声图出发，时间步取1000，UNet便可以预测第一次要去除的噪声值。然后，采样器便可以根据原始噪声图去除当前噪声值得到一张清晰一点儿的带噪声图像。反复重复这个过程，便完成了AI绘画的过程。

![](https://static001.geekbang.org/resource/image/8b/d3/8be4e96813e1ac816c964376b50297d3.jpg?wh=4409x1240)

你可能已经注意到了，每一步的加噪结果仅依赖于上一步的加噪结果和一个加噪过程，而这个加噪过程依赖于当前时间步t，因此整个加噪过程可以看成参数化的马尔科夫链。

马尔可夫链是一种数学模型，用于描述随机事件的序列，其中每个事件的概率仅取决于上一个事件的状态，而与过去的事件无关。关于马尔可夫链的更多知识，你可以点开[链接](https://en.wikipedia.org/wiki/Markov_chain)了解。

## 细节探究

理解了扩散模型的整体思路，我们再来探究下加噪和去噪的算法细节。

### 加噪过程

对于加噪过程，每一步的加噪结果是可以根据上一步的加噪结果和当前时间步t计算得到的，计算公式如下所示。

$$x\_t = \\sqrt{\\alpha\_t}x\_{t-1} + \\sqrt{1-\\alpha\_t}\\epsilon$$

公式中，$x\_t$表示第t步的加噪结果；$x\_{t-1}$表示第t-1步的加噪结果；$\\alpha\_t$是一个预先设置的超参数，用于控制随时间步的加噪强弱，你可以理解为预先设定从$\\alpha\_1$到$\\alpha\_{1000}$ 1000个参数；$\\epsilon$表示一个随机的高斯噪声。

经过数学推导，$x\_t$也可以从原始图像$x\_0$一次计算得到，你可以看下面的公式。

$$x\_t = \\sqrt{\\hat\\alpha\_t}x\_{0} + \\sqrt{1-\\hat\\alpha\_t}\\epsilon$$

公式中$x\_0$表示原始干净的图像，$\\hat\\alpha\_t$表示从$\\alpha\_1$到$\\alpha\_t$的乘积。

如果你对推导过程感兴趣，可以[点击链接](https://readpaper.com/pdf-annotate/note?pdfId=4557071478495911937&noteId=1833652073759793152)去看看原始论文。到这里，你只需要记住一个事情，**对于一张干净的图像，可以通过一次计算得到任意t步加噪声的结果**。

### 去噪过程

学习完加噪的过程，我们再来看看去噪。去噪的过程包括两层含义。

第一，如何根据当前时间步的噪声图预测上一步加入的噪声？

第二，如何在当前时间步的噪声图上去除这些噪声？

先看第一层含义，如何根据加噪结果和时间步t预测噪声呢？这里深度学习模型就能派上用场了！我们希望得到这样一个模型，输入第t步加噪结果和时间步t，预测从第t-1步到第t步噪声值。

主流的方法是训练一个UNet模型来预测噪声图。因为噪声值和输入图的分辨率是一致的，而UNet模型常用于图像分割任务，输入输出的分辨率相同，使用UNet来完成这个任务再合适不过了。

![](https://static001.geekbang.org/resource/image/4e/ba/4ec9ef7434a0bedd19699e4318bfeaba.jpg?wh=4409x2480)

接下来是第二层含义。假定我们能够成功预测出这个噪声图，又如何去除噪声呢？

答案是采样器，你可能已经从WebUI中见到过各种各样的采样器，比如DDIM、Eular A等。采样器的作用便是根据加噪结果和噪声值，准确地去除噪声。

![](https://static001.geekbang.org/resource/image/9f/fb/9f9547b04ac5935165d1abb59f9baafb.jpg?wh=4409x2480)

### 训练和推理

知道了加噪和去噪的过程，我们再来看看扩散模型的训练和推理环节，这里的训练针对的是刚刚提到的UNet黑盒，推理环节指的是从一个高斯噪声出发得到一张干净的图片。

你可以点开下面的图片查看原始论文中给出的总结，图片中推理环节对应的采样器为DDPM采样器，我们用这个采样器来帮助我们理解算法原理。

![](https://static001.geekbang.org/resource/image/d5/cd/d5bb89b63d4e2d9779528c3db6a173cd.png?wh=2790x740)

这个总结是不是看着有点懵？我来为你稍作解释。

首先对于训练过程，假定我们已经收集了一个用于训练扩散模型的训练集，整个训练过程便是不断重复下面这六个步骤。

1. 每次从数据集中随机抽取一张图片。
2. 随机从1至1000中选择一个时间步t。
3. 随机生成一个高斯噪声。
4. 根据上述加噪环节的公式，一次计算直接得到第t步加噪的结果图像。
5. 将时间步t和加噪图像作为UNet的输入去预测一个噪声值。
6. 使用第五步预测的噪声值和第三步随机生成的噪声值，计算数值误差，并回传梯度。

计算数值误差的公式如下图所示，细心的你一定已经发现了，这里用到的正是L2损失。

![图片](https://static001.geekbang.org/resource/image/b7/38/b7736ea921b8f0b6c2462a38cef12338.png?wh=5100x260)

当我们反复循环上面的过程，直到UNet的损失函数逐渐收敛到较小的数值时，比如观测一段时间，损失函数的数值不再降低，就代表我们的扩散模型就训练完成了！

训练过程的理论学完以后，我们不妨趁热打铁，再看一下训练的代码，加深理解。

```python
for i, (x_0) in enumerate(tqdm_data_loader): 
    # 将数据加载至相应的运行设备(device)
    x_0 = x_0.to(device)  
    
    # 对每一张图片随机在1~T的扩散步中进行采样
    t = torch.randint(1, T, size=(x_0.shape[0],), device=device)
    
    # 取得不同t下的 根号下alpha_t的连乘  
    sqrt_alpha_t_bar = torch.gather(sqrt_alphas_bar, dim=0, index=t).reshape(-1, 1, 1, 1)  
    
    # 取得不同t下的 根号下的一减alpha_t的连乘
    sqrt_one_minus_alpha_t_bar = torch.gather(sqrt_one_minus_alphas_bar, dim=0, index=t).reshape(-1, 1, 1, 1)
    
    # 从标准正态分布中采样得到 \epsilon 
    noise = torch.randn_like(x_0).to(device) 
    
    # 计算x_t 
    x_t = sqrt_alpha_t_bar * x_0 + sqrt_one_minus_alpha_t_bar * noise  
    
    # 将x_t输入模型 unet，得到输出
    out = net_model(x_t, t)  
    
    loss = loss_function(out, noise) # 将模型的输出，同添加的噪声做损失
    optimizer.zero_grad()  # 优化器的梯度清零
    loss.backward()  # 由损失反向求导
    optimizer.step()  # 优化器更新参数
```

训练好了UNet模型以后，我们就可以用它来进行推理了，也就是从噪声开始生成图像。一次去噪过程包括三步。

1. 我们随机生成一个高斯噪声，作为第1000步加噪之后的结果。
2. 将这个噪声和时间步1000作为已经训练好的UNet的输入，预测第999步引入的噪声。
3. 使用采样器在步骤1的高斯噪声中去除步骤2预测的噪声，得到一张干净一点的图像。

这样我们就完成了一次去噪，然后以刚得到的干净一点的图像作为起点，重复第二步、第三步，便可以得到进一步去噪的图像。对于DDPM这个“黑盒”采样器来说，将上述过程重复1000次，我们便完成了从高斯噪声得到清晰图片的过程。

我们看一下推理的代码。

```python
for t_step in reversed(range(T)):  # 从T开始向零迭代
    t = t_step
    t = torch.tensor(t).to(device)
    # 如果t大于零，则采样自标准正态分布，否则为零
    z = torch.randn_like(x_t,device=device) if t_step > 0 else 0  
    
    """这里作为示例，按照DDPM采样器公式计算"""
    x_t_minus_one = torch.sqrt(1/alphas[t])*
           (x_t-(1-alphas[t])*model(x_t, t.reshape(1,))/torch.sqrt(1-alphas_bar[t]))
           +torch.sqrt(betas[t])*z
    
    x_t = x_t_minus_one   
```

到此为止，我们已经知道了扩散模型的算法原理。

## 扩散模型 vs GAN

你可以参考后面的对比图，来理解扩散模型和GAN的原理。

![](https://static001.geekbang.org/resource/image/b4/8a/b4e35e9a2e18e733b49b26efd3c20b8a.jpg?wh=1080x352)

GAN是通过生成器、判别器对抗训练的方式来实现图像生成能力的，本质上是神经网络的左右互搏。而这一讲的扩散模型，则是通过学习一个去除噪声的过程来实现图像生成的。

通过对比的方式进行学习有助于我们加深理解，整合知识。所以我们这就来从多个维度，对比一下GAN和扩散模型的特点，你可以参考后面的表格。

![](https://static001.geekbang.org/resource/image/ee/7f/eefcc0a4732d493306059ca6e670087f.jpg?wh=4262x2312)

## 总结时刻

这一讲，我们从热力学中的扩散过程出发，理论结合实践，建立起对图像扩散模型的整体认识。

加噪过程的是通过参数化马尔可夫链将干净的图片逐步变为纯噪声；去噪的过程就是从噪声出发，逐步预测噪声并去除噪声。神经网络UNet被用于预测噪声，各式各样的采样器则用于去除噪声。

之后我们一起探究了扩散模型的算法细节，包括如何从干净图片通过一步计算到达任意步数的噪声图，如何通过DDPM采样器将噪声去除。之后还了解了如何训练一个扩散模型，以及如何使用扩散模型进行推理的过程。后面第12讲里，我们还会一起动手，从头开始训练一个扩散模型，这里先埋个伏笔。

课程最后，我们结合上一讲的内容，对于扩散模型和GAN做了对比，现在你应该对新旧两代画师各自的优缺点有了更深的认识。这里我还想提示你一下，在学习扩散模型的学习过程中，如果有不懂的概念，这时我非常鼓励你去和ChatGPT聊一聊！

![](https://static001.geekbang.org/resource/image/54/69/54fc3a5cd8dc7b3a8eb37ac30de52269.jpg?wh=3000x2854)

## 思考题

扩散模型生成速度慢是当前的痛点之一。了解了扩散模型的整体思路，你认为扩散模型的推理可以怎样加速呢？

欢迎你在留言区和我交流互动，也推荐你把这节课分享给有需要的朋友，说不定就能帮他更好地理解扩散模型。
<div><strong>精选留言（15）</strong></div><ul>
<li><span>springXu</span> 👍（2） 💬（4）<p>unet这个模型是唯一选择么？  为什么不能用其他的？  有使用其他的模型，但也是用扩散的方法的么？</p>2023-08-01</li><br/><li><span>AdamLing</span> 👍（1） 💬（1）<p>这节课对数学小白好难懂</p>2023-08-10</li><br/><li><span>bookchan</span> 👍（0） 💬（1）<p>有公式使得x_t 也可以从原始图像 x_0 一次计算得到，unet预测的是最开始的随机噪声。那么推理的时候，随机生成t步的加噪图片，根据unet预测随机噪声，那么公式反过来，我们不就一步可以直接计算得到x_0了，也就是原图，为啥还得那么多步采样。</p>2023-09-15</li><br/><li><span>bookchan</span> 👍（0） 💬（1）<p>老师，训练说到“每次从数据集中随机抽取一张图片”。不能够随机抽取batch张图片，提高训练并发度吗？</p>2023-09-15</li><br/><li><span>互联网砖瓦匠</span> 👍（0） 💬（1）<p>我感觉这些原理我看了顶多是做个了解了 数学渣渣 哈哈。</p>2023-09-04</li><br/><li><span>明远</span> 👍（0） 💬（1）<p>&gt;&gt; 公式中，xt​ 表示第 t 步的加噪结果；xt−1​ 表示第 t-1 步的加噪结果；αt​ 是一个预先设置的超参数，用于控制随时间步的加噪强弱，你可以理解为预先设定从 α1​ 到 α1000​ 1000 个参数；ϵ 表示一个随机的高斯噪声。

为什么采样器不会影响加噪的结果，这个公式是不是将加噪采样器设定为固定值了？为什么去噪声的过程可以使用不同的采样器呢？
</p>2023-08-23</li><br/><li><span>cmsgoogle</span> 👍（0） 💬（1）<p>推理过程的伪代码第4行X\_t-1的生成，第一部分是去噪，第二部分为什么又加了一个噪音，应该去再解释一下。或者留个伏笔在后续章节再详细解释。</p>2023-08-12</li><br/><li><span>一只豆</span> 👍（0） 💬（2）<p>周末看咱们整体课程目录，畅想这个单元“基础篇：AI绘画原理揭秘”的学习，看到单元末尾处的“实战项目（二）动手训练一个你自己的扩散模型” 时忽然冒出一个问题：
现在 Embedding&#47;LoRa&#47;Hypernetwork这么流行(还可多个相互配合使用)，还有Controlnet这种可控出图的神器，那么，在何种情况下（假设预算充足，追求垂直领域效果世界一流），对 Diffusion model进行什么样的定制化训练能够实现上面这些 轻量级方法不能达到的 什么样的效果呢？
我相信未来的几节原理课可能会点点滴滴的回答这个问题～ 但也许可以把这个问题当作一个 核心问题 脉络化在未来的几节课程中。。。再次感谢老师深入浅出的课程设置思想。</p>2023-07-29</li><br/><li><span>peter</span> 👍（0） 💬（1）<p>请教老师两个问题：
Q1：先加噪声，再去噪，还是不太理解为什么这样做？
喝了一口水，然后再吐掉，有意思吗？为什么就有作用？

Q2：前导篇中提到的数字人有具体产品吗？
具体产品是指：具体的网站，或者具体的客户端软件，都可以，能做出数字人。我想做一个数字人，需要用具体产品，但不知道哪个产品能做出数字人。</p>2023-07-29</li><br/><li><span>AI悦创</span> 👍（0） 💬（1）<p>到这条评论的时候，我读完了。

个人感受：这篇文章写的感觉很不错，但是读了之后但又有一些不理解的地方，具体例如：数学公式、数学公式的讲解等等知识点，感觉云里雾里，我觉得不好说好不好，希望老师后面有时间完善完善，我也会这几天再重新阅读一下，再次评论。期待老师的回复。</p>2023-07-29</li><br/><li><span>AI悦创</span> 👍（0） 💬（1）<p>对于 Diffusion 模型的加噪过程，每一步加噪依赖于时间步 t。t 越接近 0，当前加噪结果越靠近原始图像；t 越接近 1000，当前加噪结果越靠近纯噪声。

问题：为什么接近0就是原图？没 get 到</p>2023-07-28</li><br/><li><span>AI悦创</span> 👍（0） 💬（1）<p>这个步数：实验中整个加噪过程中需要 1000 次加噪操作。直觉上，从纯噪声去噪得到图像也需要 1000 次去噪操作来完成。不过，实际使用中，通过数学推导的方式可以证明并不需要 1000 步，比如我们第 1 讲中用到的 Eular 采样器，只需要 20~30 步去噪，便可以从纯噪声去噪得到清晰的图片。

是不是就是 webui 中的那个步数？</p>2023-07-28</li><br/><li><span>王大叶</span> 👍（0） 💬（2）<p>「t 的取值为 1-1000 中的一个整数，代表加噪声的步数」 这里的 1000 是固定取值吗，为什么是 1000？这个和推理过程中的 Sampling steps 是什么关系？ </p>2023-07-28</li><br/><li><span>和某欢</span> 👍（0） 💬（1）<p>经历了前面几篇文章的铺垫，终于来到了sd详解篇章！感谢老师的讲解，现在对于sd模型有了大概的了解🫡</p>2023-07-28</li><br/><li><span>hallo128</span> 👍（1） 💬（0）<p>扩散模型的数学公式推导，可以去看下这篇文献：Understanding Diffusion Models: A Unified Perspective。当然，我也做了这篇文献的精读视频，感兴趣的伙伴可以去看下：
【https:&#47;&#47;www.bilibili.com&#47;video&#47;BV1Em421s7WB&#47;?share_source=copy_web&amp;vd_source=591ed5b4226ab314d67afd7e30b5aac5】</p>2024-05-05</li><br/>
</ul>