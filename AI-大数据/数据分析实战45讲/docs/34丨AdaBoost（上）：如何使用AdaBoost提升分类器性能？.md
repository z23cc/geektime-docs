今天我们学习AdaBoost算法。在数据挖掘中，分类算法可以说是核心算法，其中AdaBoost算法与随机森林算法一样都属于分类算法中的集成算法。

集成的含义就是集思广益，博取众长，当我们做决定的时候，我们先听取多个专家的意见，再做决定。集成算法通常有两种方式，分别是投票选举（bagging）和再学习（boosting）。投票选举的场景类似把专家召集到一个会议桌前，当做一个决定的时候，让K个专家（K个模型）分别进行分类，然后选择出现次数最多的那个类作为最终的分类结果。再学习相当于把K个专家（K个分类器）进行加权融合，形成一个新的超级专家（强分类器），让这个超级专家做判断。

所以你能看出来，投票选举和再学习还是有区别的。Boosting的含义是提升，它的作用是每一次训练的时候都对上一次的训练进行改进提升，在训练的过程中这K个“专家”之间是有依赖性的，当引入第K个“专家”（第K个分类器）的时候，实际上是对前K-1个专家的优化。而bagging在做投票选举的时候可以并行计算，也就是K个“专家”在做判断的时候是相互独立的，不存在依赖性。

## AdaBoost的工作原理

了解了集成算法的两种模式之后，我们来看下今天要讲的AdaBoost算法。

AdaBoost的英文全称是Adaptive Boosting，中文含义是自适应提升算法。它由Freund等人于1995年提出，是对Boosting算法的一种实现。

什么是Boosting算法呢？Boosting算法是集成算法中的一种，同时也是一类算法的总称。这类算法通过训练多个弱分类器，将它们组合成一个强分类器，也就是我们俗话说的“三个臭皮匠，顶个诸葛亮”。为什么要这么做呢？因为臭皮匠好训练，诸葛亮却不好求。因此要打造一个诸葛亮，最好的方式就是训练多个臭皮匠，然后让这些臭皮匠组合起来，这样往往可以得到很好的效果。这就是Boosting算法的原理。

![](https://static001.geekbang.org/resource/image/8e/b4/8e88b8a952d872ea46b7dd7c084747b4.jpg?wh=2102%2A1439)  
我可以用上面的图来表示最终得到的强分类器，你能看出它是通过一系列的弱分类器根据不同的权重组合而成的。

假设弱分类器为$G\_{i}(x)$，它在强分类器中的权重$α\_{i}$，那么就可以得出强分类器f(x)：

![](https://static001.geekbang.org/resource/image/58/4f/58f7ff50e49f3cd96f6d4f0e590da04f.png?wh=183%2A67)  
有了这个公式，为了求解强分类器，你会关注两个问题：

1. 如何得到弱分类器，也就是在每次迭代训练的过程中，如何得到最优弱分类器？
2. 每个弱分类器在强分类器中的权重是如何计算的？

我们先来看下第二个问题。实际上在一个由K个弱分类器中组成的强分类器中，如果弱分类器的分类效果好，那么权重应该比较大，如果弱分类器的分类效果一般，权重应该降低。所以我们需要基于这个弱分类器对样本的分类错误率来决定它的权重，用公式表示就是：

![](https://static001.geekbang.org/resource/image/32/24/3242899fb2e4545f0aedaab7a9368724.png?wh=178%2A79)  
其中$e\_{i}$代表第i个分类器的分类错误率。

然后我们再来看下第一个问题，如何在每次训练迭代的过程中选择最优的弱分类器？

实际上，AdaBoost算法是通过改变样本的数据分布来实现的。AdaBoost会判断每次训练的样本是否正确分类，对于正确分类的样本，降低它的权重，对于被错误分类的样本，增加它的权重。再基于上一次得到的分类准确率，来确定这次训练样本中每个样本的权重。然后将修改过权重的新数据集传递给下一层的分类器进行训练。这样做的好处就是，通过每一轮训练样本的动态权重，可以让训练的焦点集中到难分类的样本上，最终得到的弱分类器的组合更容易得到更高的分类准确率。

我们可以用$D\_{k+1}$代表第k+1轮训练中，样本的权重集合，其中$W\_{k+1,1}$代表第k+1轮中第一个样本的权重，以此类推$W\_{k+1,N}$代表第k+1轮中第N个样本的权重，因此用公式表示为：

![](https://static001.geekbang.org/resource/image/d9/b6/d9b32e1d065e39861f266709640b2bb6.png?wh=331%2A61)  
第k+1轮中的样本权重，是根据该样本在第k轮的权重以及第k个分类器的准确率而定，具体的公式为：

![](https://static001.geekbang.org/resource/image/1a/58/1a6c650c3b7aa6d44cccf3b9dff81258.png?wh=393%2A71)

## AdaBoost算法示例

了解AdaBoost的工作原理之后，我们看一个例子，假设我有10个训练样本，如下所示：

![](https://static001.geekbang.org/resource/image/73/38/734c8272df1f96903be1777733a10f38.png?wh=630%2A75)  
现在我希望通过AdaBoost构建一个强分类器。

该怎么做呢？按照上面的AdaBoost工作原理，我们来模拟一下。

首先在第一轮训练中，我们得到10个样本的权重为1/10，即初始的10个样本权重一致，D1=(0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1)。

假设我有3个基础分类器：

![](https://static001.geekbang.org/resource/image/32/a4/325756eb08b5b3fd55402c9a8ba4dca4.png?wh=194%2A233)  
我们可以知道分类器f1的错误率为0.3，也就是x取值6、7、8时分类错误；分类器f2的错误率为0.4，即x取值0、1、2、9时分类错误；分类器f3的错误率为0.3，即x取值为3、4、5时分类错误。

这3个分类器中，f1、f3分类器的错误率最低，因此我们选择f1或f3作为最优分类器，假设我们选f1分类器作为最优分类器，即第一轮训练得到：

![](https://static001.geekbang.org/resource/image/3d/fb/3dd329577aef1a810a1c130095a3e0fb.png?wh=179%2A72)  
根据分类器权重公式得到：

![](https://static001.geekbang.org/resource/image/f9/60/f92e515d7ad7c1ee5f3bf45574bf3060.png?wh=266%2A76)  
然后我们对下一轮的样本更新求权重值，代入$W\_{k+1,i}$和$D\_{k+1}$的公式，可以得到新的权重矩阵：D2=(0.0715, 0.0715, 0.0715, 0.0715, 0.0715, 0.0715, 0.1666, 0.1666, 0.1666, 0.0715)。

在第二轮训练中，我们继续统计三个分类器的准确率，可以得到分类器f1的错误率为0.1666\*3，也就是x取值为6、7、8时分类错误。分类器f2的错误率为0.0715\*4，即x取值为0、1、2、9时分类错误。分类器f3的错误率为0.0715\*3，即x取值3、4、5时分类错误。

在这3个分类器中，f3分类器的错误率最低，因此我们选择f3作为第二轮训练的最优分类器，即：

![](https://static001.geekbang.org/resource/image/68/40/687202173085a62e2c7b32deb05e9440.png?wh=200%2A79)  
根据分类器权重公式得到：

![](https://static001.geekbang.org/resource/image/ce/8b/ce8a4e319726f159104681a4152e3a8b.png?wh=245%2A70)  
同样，我们对下一轮的样本更新求权重值，代入$W\_{k+1,i}$和$D\_{k+1}$的公式，可以得到D3=(0.0455,0.0455,0.0455,0.1667, 0.1667,0.01667,0.1060, 0.1060, 0.1060, 0.0455)。

在第三轮训练中，我们继续统计三个分类器的准确率，可以得到分类器f1的错误率为0.1060\*3，也就是x取值6、7、8时分类错误。分类器f2的错误率为0.0455\*4，即x取值为0、1、2、9时分类错误。分类器f3的错误率为0.1667\*3，即x取值3、4、5时分类错误。

在这3个分类器中，f2分类器的错误率最低，因此我们选择f2作为第三轮训练的最优分类器，即：

![](https://static001.geekbang.org/resource/image/88/15/8847a9e60b38a79c08086e1620d6d915.png?wh=192%2A70)  
我们根据分类器权重公式得到：

![](https://static001.geekbang.org/resource/image/0e/c3/0efb64e73269ee142cde91de532627c3.png?wh=267%2A86)  
假设我们只进行3轮的训练，选择3个弱分类器，组合成一个强分类器，那么最终的强分类器G(x) = 0.4236G1(x) + 0.6496G2(x)+0.7514G3(x)。

实际上AdaBoost算法是一个框架，你可以指定任意的分类器，通常我们可以采用CART分类器作为弱分类器。通过上面这个示例的运算，你体会一下AdaBoost的计算流程即可。

## 总结

今天我给你讲了AdaBoost算法的原理，你可以把它理解为一种集成算法，通过训练不同的弱分类器，将这些弱分类器集成起来形成一个强分类器。在每一轮的训练中都会加入一个新的弱分类器，直到达到足够低的错误率或者达到指定的最大迭代次数为止。实际上每一次迭代都会引入一个新的弱分类器（这个分类器是每一次迭代中计算出来的，是新的分类器，不是事先准备好的）。

在弱分类器的集合中，你不必担心弱分类器太弱了。实际上它只需要比随机猜测的效果略好一些即可。如果随机猜测的准确率是50%的话，那么每个弱分类器的准确率只要大于50%就可用。AdaBoost的强大在于迭代训练的机制，这样通过K个“臭皮匠”的组合也可以得到一个“诸葛亮”（强分类器）。

当然在每一轮的训练中，我们都需要从众多“臭皮匠”中选择一个拔尖的，也就是这一轮训练评比中的最优“臭皮匠”，对应的就是错误率最低的分类器。当然每一轮的样本的权重都会发生变化，这样做的目的是为了让之前错误分类的样本得到更多概率的重复训练机会。

同样的原理在我们的学习生活中也经常出现，比如善于利用错题本来提升学习效率和学习成绩。

![](https://static001.geekbang.org/resource/image/10/00/10ddea37b3fdea2ec019f38b59ac6b00.png?wh=1483%2A419)  
最后你能说说你是如何理解AdaBoost中弱分类器，强分类器概念的？另外，AdaBoost算法是如何训练弱分类器从而得到一个强分类器的？

欢迎你在评论区与我分享你的答案，也欢迎点击“请朋友读”，把这篇文章分享给你的朋友或者同事。
<div><strong>精选留言（15）</strong></div><ul>
<li><span>third</span> 👍（22） 💬（2）<p>
作业
1.假设分类正确就是吃鸡成功。

1）训练多个弱分类器，并不断迭代弱分类器，选择最优弱分类器
枪法，一个弱分类器，你可以通过玩的越来越多，练习越来越好
身法，一个弱分类器，同理
意识，一个弱分类器。同理
···


2）将弱分类器组合起来，形成一个强分类器

枪法，身法，眼神，你只有一个的话，实际上，你的吃鸡概率并不高。但是三个都好的人，吃鸡概率就是高。这就是强分类器。

2.把分类正确理解成功的的话，

1）训练多个弱分类器，并不断迭代弱分类器，选择最优弱分类器
努力获取了一个领域的知识和道理，就是一个弱分类器，不断地学习和精进，在一个知识领域变得更强

3）将弱分类器组合起来，形成一个强分类器
合理跨界，将两个领域的知识组合起来，产生新收益。比如软硬件结合的苹果，仅一家公司就占据了整个手机市场利润的50%以上。

两个领域的组合，就是一个强分类器。


理解
1.通过修改样本的数据分布来实现算法的。
正确分类的，就少分点
错误分类的，就多分点。

像做题，
做正确的题，下次就少做点，反正会了。
做错的题，下次多做点，集中在错题上
每次这个题都在变化，随着你学习的深入，你做错的题会越来越少。


2.样本的权重时根据之前的k论权重以及k个分类器的准确率而定的。

你决定做什么样题。
1.取决于你上次做对了什么题，做错了什么题
2.做正确了，你就少做点。
3.做错了，你就多做点。

提问：Zk是啥意思？，yi是啥意思？

流程
1.获取基础权重
2.获取基础分类器
3.计算错误率，选择错误率最低的为最优分类器
4.通过计算分类器权重公式，达到减少正确样本数据分布，增加错误样本数据分布
5.代入W k+1,i和D k+1 的公式，得到新的权重矩阵
7.在新的权重矩阵上，计算错误率，选择错误最低的为最优分类器
剩下的就是迭代，重复
直到迭代完成，获得强分类器
</p>2019-03-01</li><br/><li><span>清夜</span> 👍（12） 💬（1）<p>多个弱分类器训练成为一个强分类器。
类比为：
全班同学都做一张正常的高中试卷，但是每道题无论大小都是一样的分数。
1.  给得分最高的同学赋予一个比他人更高的权重，并且他做错的题目分数都提高一些。
2. 重新计分，选择此时分数最高的人赋予一定权重，提高他做错题目的分数。
3. 不断重复以上步骤。
4. 每个同学都重新有了权重之后，一个强分类器就诞生了。</p>2019-10-30</li><br/><li><span>Ehh1ouyz</span> 👍（8） 💬（3）<p>补充：这里的Zk是归一化因子。</p>2019-03-03</li><br/><li><span>Geek_hve78z</span> 👍（8） 💬（1）<p>如何理解 AdaBoost 中弱分类器，强分类器概念的？另外，AdaBoost 算法是如何训练弱分类器从而得到一个强分类器的？

1、弱分类器，是指基础分类器，正确率略高于50%的那种。
强分类器是通过训练出多个弱分类器，并赋值权重，最后形成弱分类器+权重的模型。

2、得到强分类器的方法：
参考链接：https:&#47;&#47;www.cnblogs.com&#47;hlongch&#47;p&#47;5734293.html
adaboost算法的核心思想是针对同一个训练集训练不同的分类器(弱分类器)，然后把这些弱分类器集合起来，构成一个更强的最终分类器(强分类器)。

1.一开始，给训练数据中的每一个样本，赋予其一个权重，权重都初始化成相等值。如（1&#47;样本数量）
2.首先在训练数据中训练出一个弱分类器并计算改分类器的错误率，选取错误率最小的分类器，并基于分类器错误率计算其权重值alpha。
3.在分类器的第二次训练当中，将会重新调整每个样本的权重，其中第一次分对的样本的权重将会降低，而第一次分错的样本权重将会提高。然后在同一数据集上再次训练弱分类器。得出第二个错误率小的分类器，并基于错误率计算权重。
4.重复“重新分配样本权重——计算分类器错误率——选取分类器——计算分类器权重”

5.最后将每次训练得到的分类器最后融合起来，作为最后的决策分类器。</p>2019-03-01</li><br/><li><span>三硝基甲苯</span> 👍（4） 💬（1）<p>根据我的反推，首先这里的所有涉及到对数和指数的都是以e为底的，然后就是Dk+1这一步，需要先计算Zk，这个就是把 wk*e^(-ak*y*Gk(x))把全部的加起来就是了，然后再去算Wk+1，然后就进一步可以算出Dk+1。
个人理解就是AdaBoost就是先把数据通过权重的方式分割成不同的部分，然后每个部分再去交给在这些里较为专业的分类器去分类，通过迭代，再把计算的结果带上权重后，就是结果了。</p>2019-03-23</li><br/><li><span>Ronnyz</span> 👍（3） 💬（1）<p>弱分类器：分类准确率比较低，可能在(50%~70%)之间
强分类器：在AdaBoost算法中，将一系列的弱分类器以不同的权重比组合作为最终分类选择
在筛选每一轮的最优分类器后，调整样本的权重，以获得一个更优的弱分类器。</p>2019-11-24</li><br/><li><span>Geek_c9fa4e</span> 👍（2） 💬（1）<p>1、假设AdaBoost算法是球队
弱分类器：在众多球队里，踢得不好的队伍
强分类器：通过在弱分类不断地寻找出弱分类里面踢得好的，最后组成一个强的球队
2、如何训练成强分类器：
  1、首先初始化一个相同权重。
  2、然后在训练数据中计算弱分类·的错误率，选择错误率最低的去计算该权重
  3、接着再次训练，重新调整每个样本的权重，其中第一次分对的样本的权重将会降低，而第一次分错的样本权重将会提高。然后在同一数据集上再次训练弱分类器。得出第二个错误率小的分类器，并基于错误率计算权重。
  4、重复此步骤
  5、最后将每次训练得到的分类器最后融合起来，作为最后的决策分类器。</p>2020-04-30</li><br/><li><span>juixv3937</span> 👍（0） 💬（3）<p>log没有底数怎么计算啊</p>2019-08-18</li><br/><li><span>滨滨</span> 👍（0） 💬（1）<p>弱分类器分类正确率比随机稍微高一点，每次选择相对最优的分类器，然后对分类错误的部分加强训练，最后得到一个强分类器。

1.一开始，给训练数据中的每一个样本，赋予其一个权重，权重都初始化成相等值。如（1&#47;样本数量）
2.首先在训练数据中训练出一个弱分类器并计算改分类器的错误率，选取错误率最小的分类器，并基于分类器错误率计算其权重值alpha。
3.在分类器的第二次训练当中，将会重新调整每个样本的权重，其中第一次分对的样本的权重将会降低，而第一次分错的样本权重将会提高。然后在同一数据集上再次训练弱分类器。得出第二个错误率小的分类器，并基于错误率计算权重。
4.重复“重新分配样本权重——计算分类器错误率——选取分类器——计算分类器权重”

5.最后将每次训练得到的分类器最后融合起来，作为最后的决策分类器。</p>2019-04-21</li><br/><li><span>李沛欣</span> 👍（0） 💬（1）<p>通过训练多个弱分类器，集成一个强分类器。</p>2019-03-16</li><br/><li><span>Python</span> 👍（0） 💬（1）<p>弱分类器是决策层，强分类器是决策汇总后的结果</p>2019-03-02</li><br/><li><span>Geek_3e33b6</span> 👍（1） 💬（0）<p>1&#47;2 * log((1-0.3)&#47;0.3) = 0.184   为啥文章里是0.4236</p>2022-12-15</li><br/><li><span>Untitled</span> 👍（1） 💬（0）<p>整个算法流程我自己理解为把上一次分类错误的缺点放大，优点缩小，然后等另一个分类器来把放到的缺点进行优化。</p>2020-03-08</li><br/><li><span>那时刻</span> 👍（1） 💬（0）<p>老师，你好。请问样本权重的计算公式是个指数函数exp，为啥是指数函数？不用指数的话，有啥不同么？</p>2019-03-01</li><br/><li><span>教育兴国，科技强国</span> 👍（0） 💬（0）<p>这个样本权重的公式是咋样来的啊？
第 k+1 轮中的样本权重，是根据该样本在第 k 轮的权重以及第 k 个分类器的准确率而定，具体的公式就是那个：w(k+i,i)=.....</p>2022-04-26</li><br/>
</ul>