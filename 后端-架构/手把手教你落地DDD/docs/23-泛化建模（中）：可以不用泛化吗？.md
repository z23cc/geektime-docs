你好，我是钟敬。

上节课，我们学习了“泛化”，并用这个技术完成了“在子项目上报工时”的需求。如果你是第一次学的话，可能会觉得理解起来有一些难度吧。

今天，我们继续这个建模过程，首先考虑“在子项目上报工时”这个需求的更多细节，增加更多的灵活性。

然后，我们来考虑另一个需求——“为内部项目报工时”。我们会采用使用泛化和**不**使用泛化两种方式为这个需求建模，并且比较两者的异同，以便你更进一步理解泛化的思路。事实上，用不用泛化有时不是一个非黑即白的决定，而是一种权衡。

还是我当项目经理，你当架构师。

## 增强灵活性

我们先回顾一下上节课建立的模型。

![](https://static001.geekbang.org/resource/image/08/5e/087bcd7e7f7f6a1be8a20abc3f90a25e.jpg?wh=3359x2368)

到现在为止，我们的模型已经基本可以满足按**项目**、**子项目**和**普通工时项**来报工时的需求了。

我们简单复述一下目前的需求。

- “零零后公司”只能按项目登记工时。
- “九零后公司”只能按子项目登记工时。
- “八零后公司”既可以按项目也可按子项目，还可以按普通工时项登记工时。

现在我开始向你提几个更深入的问题。

**第一个问题**是：怎么控制“零零后公司”**只能**按项目，而不能按子项目报工时呢？反之，怎么控制“九零后公司”只能按子项目报工时呢？

为了解决这个问题，你决定为每个租户增加一个配置参数。

![](https://static001.geekbang.org/resource/image/1a/f6/1aaff247659e9ee43ef44aeef6a87df6.jpg?wh=3359x2368)

所有租户级的参数，都在**租户参数**这个实体里。我们商量了一下，把新的参数命名为**项目工时粒度**，有三个选项，分别是：“项目”“子项目”和“两可”。对于“零零后公司”只要把这个参数设置成“项目”，就说明只能按**项目**来报工时。对于其他两个公司的需求，道理是一样的。

这样也解决了另一个问题，就是，万一“零零后公司”将来也想按子项目来报工时的话，我们只需要改一下这个参数的设置就可以了。

我的**第二个问题**是：对于多数公司，按**普通工时项**报工时应该是一个很普遍的需求。虽然“零零后公司”现在不需要这样报工时，但将来如果要，怎么办呢？

你告诉我：“**普通工时项**在数据库里会映射成一个表。对于“零零后公司”，这个表里没有记录，那么自然就只能按项目报工时。将来如果需要按普通工时来报，例如“学习时间”，那么只需要把“学习时间”这条记录插到表里就可以使用了。所以模型不需要任何修改。

这时候你又反问了我**一个问题**：“八零后公司”既可以按**项目**也可按**子项目**来报工时，也就是参数里的“两可”。但是“两可”的具体含义是什么呢？因为其实可以有两种不同的理解。

**第一种理解**是，任何项目都“两可”。比如有一个项目A，那么每一个员工，既可以把工时报到项目A整体上，而不区分子项目，也可以把工时报到项目A的某个子项目上，完全取决于员工自己的选择。

**第二种理解**是，对于某一个具体项目而言，只能在“按项目”和“按子项目”中选择一种。例如，项目A，只能按项目整体报工时；项目B，只能按子项目报工时。而对于整个公司而言，由于同时存在A和B两种情况，所以在整体上是“两可”。

我思考了一下，说：“确实有这两种细微的差别。但是如果在租户的参数上，再区分这两种情况的话，可能反而会把用户搞糊涂。”

事实上，之所以有“两可”这个选项，无非是想给项目自身一个灵活性，如果把这个选项放在项目级别，由项目经理来决定，似乎更合适。但是全局的参数仍然可以保留，作为默认值，具体项目可以修改默认值。基于这个思路，你尝试这样修改了模型。

![](https://static001.geekbang.org/resource/image/56/a0/5660c763b8aaeafa4663d9f2c7f1c5a0.jpg?wh=3359x2368)

你对模型做了三点改动。

**第一**，把租户参数里原来的“项目工时粒度”，改成了“**默认**项目工时粒度”。也就是说，这个选项可以被具体的**项目**覆盖。

**第二**，你用一个注解，明确了“两可”的含义，也就是你所说的第一种理解：“两可”指的是，对于一个项目，既可以把工时报在项目整体上，也可以报在它的子项目上，取决于员工自己的选择。

**第三**，在**项目**实体上增加了一个**工时粒度**属性，它的可选项和租户参数里是一样的。这样就可以在**项目**中进行细粒度的配置了。

有了这几个改动，就可以在租户参数里设置最常用的选项作为默认值，然后让项目经理在项目级别决定是否要覆盖默认值。这样就能满足“八零后公司”的需求了。

但是这样的话，对于“零零后公司”，岂不是也可以由项目经理自行配置了？这显然不符合当前的需求。

于是你又增加了一个租户级别的参数。

![](https://static001.geekbang.org/resource/image/37/bb/370c38054db7d0e0d00bbaa1315143bb.jpg?wh=3359x2368)

这个参数就是“是否可覆盖默认项目工时粒度”。对于“零零后公司”和“九零后公司”，把这个参数设为“否”，对于“八零后公司”设为“是”。这样一来，就可以同时满足这三个公司的不同需求了。

而且，不只是这三家公司，对于更多的公司的类似需求来说，上面的设计也足以满足了。当然，如果以后再遇到更“古怪”的需求，我们可以遵循类似的思路去增加系统的灵活性。

我们再思考一下，前面的做法算不算“过度设计”呢？

我的看法是这样的：如果是给某一家公司量身定做一个系统的话，本来不需要考虑这么多。但作为一个 SaaS 系统，要面对各种不同的用户，所以就要把系统设计得灵活一些了。假如局限于某个特定的公司，这样做可能有“过度设计”的嫌疑。但对于 SaaS 应用，这样的设计应该是恰当的。

## 非客户项目的泛化

现在，我们再来考虑“九零后公司”的另一个需求，并尝试用泛化来建模。

这个需求是这样的：九零后公司有一些公司内部的项目，比如说几个小伙伴一起搞一个内部开源的项目。和客户项目不同，这些内部项目没有合同，也不需要专门分配人力，而是谁有空，就可以随时参与。

于是你问我：“是不是可以说，客户项目和内部项目统称为项目，他们的共性是都可以报工时？”

我说：“可以这么理解。”

你紧跟着问：“这么说，内部项目岂不就是普通工时项？是不是可以直接用普通工时项实现这个需求呢？”

我想了一下，说：“内部项目和客户项目还有更多的共性，是普通工时项所不具备的，比如说，作为项目，内部项目也有项目经理，也有子项目，也有明确的起止时间，也有项目状态等等。”

你觉得言之有理，于是利用泛化的知识，画出了后面的模型图。  
![](https://static001.geekbang.org/resource/image/48/60/485fe00971e88002077bcd0004e83e60.jpg?wh=3359x2256)

从这个图里，我们看到，作为父类的**项目**实体，反映了**客户项目**和**内部项目**的共性，例如都有项目经理，都可以建立子项目等等；而**客户项目**体现了与**内部项目**的区别或者说个性，例如一个客户项目必须属于某个合同，并且需要分配项目成员，而内部项目则不具有这两个特征。所以，目前这个模型确实反映了需求中的领域知识。

## 一定要泛化吗？

我仔细看了这个模型，然后又问了一个问题：“我承认这个模型正确地反映了需求，但是泛化似乎让这个模型变得更复杂了，有没有可能画一个不用泛化的模型，看看效果怎么样呢？”

你说：“也可以，我们比较一下吧。”

于是，你又画出了后面这个等价的模型。  
![](https://static001.geekbang.org/resource/image/41/2c/41137f8bb4ee320c700e45b6a80a022c.jpg?wh=3439x2256)

可以看到，这个模型也正确地反映了同样的需求。如果把这个模型和没有反映“客户项目和内部项目”需求的模型，也就是这节课的第一张图相对比，就会发现，这个模型只有三个主要变化。

第一，在项目与合同的关联上，合同一端的多重性由“1..1”变成了“0..1”。这是因为，原来，一个项目必须属于某个合同，而现在，内部项目没有合同，也就是说，有的项目可以对应“0”个合同。

第二，在项目实体中增加了一个“是否客户项目”的标志，这样就代替了原来泛化符号起到的区分两种项目的作用。

第三，增加了两个约束，用于说明客户项目和内部项目的区别。而在采用泛化的模型中，并不需要这两个约束，因为模型本身的结构已经说明了相同的知识。

这时候我说：“站在产品经理的角度，不用泛化的模型，比起之前没有这个新需求的模型（“增强灵活性”一节的最后一张图）来说，并没有增加或者减少任何关联，而且由于没有用泛化，更简单，更容易理解，你觉得呢？”

你说：“从架构师的角度，这个模型也更容易实现。既然这样，咱们还是不用泛化了吧。” 于是我们达成了一致。

## 继续增强灵活性

你又看了一下和“是否客户项目”有关的业务规则，然后问了我另一个问题：“‘是否客户项目’和‘是否要分配项目成员’，是同一个维度的问题吗？比如说，会不会内部项目也要分配成员呢？”

我想了想说：“你说得对。尽管九零后公司自己认为这是一回事，但如果把这个应用卖给其他用户，可能就会出现内部项目也要分配成员的情况。也就是说，现在的模型还缺乏通用性。所以，把这两者当做两个维度，分开设置比较好。”

于是你又修改了模型。

![](https://static001.geekbang.org/resource/image/1f/54/1f503dc11e5cb16bb82874fc3a1e5454.jpg?wh=3439x2256)

在项目里增加了一个“是否要分配项目成员”的属性，和“是否客户项目”分开。然后，在原来关于“是否客户项目”的注释里，删除了有关分配项目成员的约束，因为“是否要分配项目成员”这个属性本身已经不言自明了。

这时候我问了你今天最后一个问题：“回过头来想一下，如果把‘是否客户项目’和‘是否要分配项目成员’都用泛化的方式表示，模型会变成什么样子呢？”

于是，你画出了后面的模型。  
![](https://static001.geekbang.org/resource/image/d1/e8/d1d3cb07ca922d3881b760a2e23092e8.jpg?wh=3439x2256)

比起前面的图，这个模型更加复杂，理解起来更困难一些。所以，我们决定还是选择前面简单些的模型。

另外，这个模型实际上是按照两个不同的维度进行泛化的，称为“多重泛化”。我们在第三个迭代再来讨论这种复杂的情况。

## 总结

好，这节课的主要内容就讲到这，我们来总结一下。

今天，为了实现“为内部项目报工时”引发的需求，我们比较了使用泛化和不使用泛化两种方式。最后选择了从业务和技术视角都更加简单的，不使用泛化的方式。这说明，使用或者不使用泛化，是一个需要权衡的决策。在权衡过程中，需要结合业务和技术视角。

另外，通过为两个需求增加灵活性，我们也体会到，相比给特定企业定制的系统，SaaS系统往往需要考虑更多的灵活性。

不过，在使用还是不使用泛化这个问题上，你可能还是觉得，似乎现在是在凭“直觉”进行的判断。下节课，我们继续深入，聊聊权衡背后更多的思路和规律。

## 思考题

下面我给你留了两道思考题。

1.回顾上个迭代的需求，**开发中心**、**直属部门**和**组织**之间，是否应该用泛化来抽象呢？

2.领域建模里的泛化常常对应着面向对象编程里的继承，事实上，UML的符号都是相同的。而课程里说的多重泛化，在编程时则不能用继承直接实现，你能想到为什么吗？

好，今天的课程结束了，有什么问题欢迎在评论区留言，下节课，我们来讨论怎样权衡是否要使用泛化。
<div><strong>精选留言（10）</strong></div><ul>
<li><span>子衿</span> 👍（16） 💬（2）<p>1. 结合我原来的知识，我理解是否要使用泛化，其实讨论的就是到底是使用继承，还是使用一个状态位来表达区别，那最终其实就是对面向过程还是面向对象的一个权衡，如果不用泛化，而是新增一个属性表示区别，如果该属性只影响这个类的一小部分行为还好，只需在这一小部分行为中加入if..else即可，但如果这个属性，影响了这个类的大部分行为，那就会产生一堆的if..else，此时不如使用泛化，让代码更面向对象，对于上一个迭代，我觉得开发中心、直属部门和组织之间的区别在于他们的性质，而性质这个属性对他们的行为影响不大，可以考虑不使用泛化实现
2. 多重泛化不能使用继承是因为java中不支持多继承，如果非使用继承实现，就会造成类的泛滥，这其实就是设计模式中桥接模式解决的问题</p>2023-02-02</li><br/><li><span>赵晏龙</span> 👍（3） 💬（2）<p>1 考虑泛化后增加模型复杂度，并且没有提供任何的必要性或者好处，我倾向于不使用泛化。

2 java .net里不能有多个父类？那我CPP来！等等，我是不是泄漏了内存？为什么提示我地址非法？你们先设计模型，我解决完这些马上就来！</p>2023-02-16</li><br/><li><span>邓西</span> 👍（2） 💬（1）<p>1. 个人理解，是否需要泛化的评判标准应该是各差异属性是否可以归类，用枚举等方式便可区分。如果是，那就没有必要泛化。
2. 求解。语言特性决定？Java不支持多继承，但C++可以</p>2023-02-17</li><br/><li><span>特修斯之船</span> 👍（2） 💬（2）<p>我怎么感觉泛化的图更好理解，不喜欢用注解</p>2023-02-15</li><br/><li><span>阿昕</span> 👍（2） 💬（1）<p>思考题，开发中心、直属部门和组织之间，主要区别体现在类型、上下级关系之间，只有属性的差异，不用泛化</p>2023-02-08</li><br/><li><span>NoSuchMethodError</span> 👍（1） 💬（1）<p>泛化不泛化取决于是否具有属性的差异</p>2023-04-10</li><br/><li><span>6点无痛早起学习的和尚</span> 👍（1） 💬（1）<p>思考题，看了老师给别人的回复，想到了目前代码里实现的一个点，就采用了泛化类似的想法，感觉这也是一个泛化
在代码里的领域层的对象，都继承了AuditableEntity，这个就是不同对象之间的共性，子类又有不同的个性（字段属性）

不知道这样认为对不对</p>2023-02-20</li><br/><li><span>颜如玉</span> 👍（0） 💬（1）<p>继承通常只能解决单维度的泛化问题，多重泛化有多个维度</p>2023-07-09</li><br/><li><span>zenk</span> 👍（0） 💬（1）<p>JAVA 每个泛化一个方法，不同的实现对应不同的泛化，而且一一对应，只是子类比较多，是每种泛化种类的乘积</p>2023-03-02</li><br/><li><span>tt</span> 👍（0） 💬（1）<p>我觉得开发中心、直属部门和组织之间确实是泛化的关系，但是在这个项目里它们几乎是会存在的实体，为了明确，可以不用泛化实现。

至于多重泛化，我觉得不像是继承，而像是C++模板中的“偏特化”，就是对于模板中的某个属性做特定的实例化。所以不适合用继承实现。</p>2023-02-05</li><br/>
</ul>