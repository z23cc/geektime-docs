你好，我是景霄。

在前面的第一大章节中，我们一起学习了Python的函数基础及其应用。我们大致明白了，所谓的传参，就是把一些参数从一个函数传递到另一个函数，从而使其执行相应的任务。但是你有没有想过，参数传递的底层是如何工作的，原理又是怎样的呢？

实际工作中，很多人会遇到这样的场景：写完了代码，一测试，发现结果和自己期望的不一样，于是开始一层层地debug。花了很多时间，可到最后才发现，是传参过程中数据结构的改变，导致了程序的“出错”。

比如，我将一个列表作为参数传入另一个函数，期望列表在函数运行结束后不变，但是往往“事与愿违”，由于某些操作，它的值改变了，那就很有可能带来后续程序一系列的错误。

因此，了解Python中参数的传递机制，具有十分重要的意义，这往往能让我们写代码时少犯错误，提高效率。今天我们就一起来学习一下，Python中参数是如何传递的。

## **什么是值传递和引用传递**

如果你接触过其他的编程语言，比如C/C++，很容易想到，常见的参数传递有2种：**值传递**和**引用传递**。所谓值传递，通常就是拷贝参数的值，然后传递给函数里的新变量。这样，原变量和新变量之间互相独立，互不影响。

比如，我们来看下面的一段C++代码：

```
#include <iostream>
using namespace std;
 
// 交换2个变量的值
void swap(int x, int y) {
int temp;
temp = x; // 交换x和y的值
 x = y;
 y = temp;
 return;
}
int main () {
 int a = 1;
 int b = 2;
 cout << "Before swap, value of a :" << a << endl;
 cout << "Before swap, value of b :" << b << endl;
 swap(a, b); 
 cout << "After swap, value of a :" << a << endl;
 cout << "After swap, value of b :" << b << endl;
 return 0;
}
Before swap, value of a :1
Before swap, value of b :2
After swap, value of a :1
After swap, value of b :2
```

这里的swap()函数，把a和b的值拷贝给了x和y，然后再交换x和y的值。这样一来，x和y的值发生了改变，但是a和b不受其影响，所以值不变。这种方式，就是我们所说的值传递。

所谓引用传递，通常是指把参数的引用传给新的变量，这样，原变量和新变量就会指向同一块内存地址。如果改变了其中任何一个变量的值，那么另外一个变量也会相应地随之改变。

还是拿我们刚刚讲到的C++代码为例，上述例子中的swap()函数，如果改成下面的形式，声明引用类型的参数变量：

```
void swap(int& x, int& y) {
   int temp;
   temp = x; // 交换x和y的值
   x = y;
   y = temp;
   return;
}
```

那么输出的便是另一个结果：

```
Before swap, value of a :1
Before swap, value of b :2
After swap, value of a :2
After swap, value of b :1
```

原变量a和b的值被交换了，因为引用传递使得a和x，b和y一模一样，对x和y的任何改变必然导致了a和b的相应改变。

不过，这是C/C++语言中的特点。那么Python中，参数传递到底是如何进行的呢？它们到底属于值传递、引用传递，还是其他呢？

在回答这个问题之前，让我们先来了解一下，Python变量和赋值的基本原理。

## **Python变量及其赋值**

我们首先来看，下面的Python代码示例：

```
a = 1
b = a
a = a + 1
```

这里首先将1赋值于a，即a指向了1这个对象，如下面的流程图所示：

![](https://static001.geekbang.org/resource/image/97/eb/97c05df49cfe051d7b76addd833f33eb.png?wh=422%2A214)

接着b = a则表示，让变量b也同时指向1这个对象。这里要注意，Python里的对象可以被多个变量所指向或引用。

![](https://static001.geekbang.org/resource/image/c0/9f/c00c9fc013cea4eb840921eb4b3e499f.png?wh=350%2A336)

最后执行a = a + 1。需要注意的是，Python的数据类型，例如整型（int）、字符串（string）等等，是不可变的。所以，a = a + 1，并不是让a的值增加1，而是表示重新创建了一个新的值为2的对象，并让a指向它。但是b仍然不变，仍然指向1这个对象。

因此，最后的结果是，a的值变成了2，而b的值不变仍然是1。

![](https://static001.geekbang.org/resource/image/fc/17/fc10cd3e3512e984d530a4b82259e917.png?wh=422%2A290)

通过这个例子你可以看到，这里的a和b，开始只是两个指向同一个对象的变量而已，或者你也可以把它们想象成同一个对象的两个名字。简单的赋值b = a，并不表示重新创建了新对象，只是让同一个对象被多个变量指向或引用。

同时，指向同一个对象，也并不意味着两个变量就被绑定到了一起。如果你给其中一个变量重新赋值，并不会影响其他变量的值。

明白了这个基本的变量赋值例子，我们再来看一个列表的例子：

```
l1 = [1, 2, 3]
l2 = l1
l1.append(4)
l1
[1, 2, 3, 4]
l2
[1, 2, 3, 4]
```

同样的，我们首先让列表l1和l2同时指向了\[1, 2, 3]这个对象。

![](https://static001.geekbang.org/resource/image/c2/f9/c2f8e0d9a8570bd56a43a21b7bb25af9.png?wh=662%2A370)

由于列表是可变的，所以l1.append(4)不会创建新的列表，只是在原列表的末尾插入了元素4，变成\[1, 2, 3, 4]。由于l1和l2同时指向这个列表，所以列表的变化会同时反映在l1和l2这两个变量上，那么，l1和l2的值就同时变为了\[1, 2, 3, 4]。

![](https://static001.geekbang.org/resource/image/b1/5f/b16d29112c361f596952961d13da345f.png?wh=694%2A358)

另外，需要注意的是，Python里的变量可以被删除，但是对象无法被删除。比如下面的代码：

```
l = [1, 2, 3]
del l
```

del l 删除了l这个变量，从此以后你无法访问l，但是对象\[1, 2, 3]仍然存在。Python程序运行时，其自带的垃圾回收系统会跟踪每个对象的引用。如果\[1, 2, 3]除了l外，还在其他地方被引用，那就不会被回收，反之则会被回收。

由此可见，在Python中：

- 变量的赋值，只是表示让变量指向了某个对象，并不表示拷贝对象给变量；而一个对象，可以被多个变量所指向。
- 可变对象（列表，字典，集合等等）的改变，会影响所有指向该对象的变量。
- 对于不可变对象（字符串、整型、元组等等），所有指向该对象的变量的值总是一样的，也不会改变。但是通过某些操作（+=等等）更新不可变对象的值时，会返回一个新的对象。
- 变量可以被删除，但是对象无法被删除。

## **Python函数的参数传递**

从上述Python变量的命名与赋值的原理讲解中，相信你能举一反三，大概猜出Python函数中参数是如何传递了吧？

这里首先引用Python官方文档中的一段说明：

> “Remember that arguments are passed by assignment in Python. Since assignment just creates references to objects, there’s no alias between an argument name in the caller and callee, and so no call-by-reference per Se.”

准确地说，Python的参数传递是**赋值传递** （pass by assignment），或者叫作对象的**引用传递**（pass by object reference）。Python里所有的数据类型都是对象，所以参数传递时，只是让新变量与原变量指向相同的对象而已，并不存在值传递或是引用传递一说。

比如，我们来看下面这个例子：

```
def my_func1(b):
	b = 2

a = 1
my_func1(a)
a
1
```

这里的参数传递，使变量a和b同时指向了1这个对象。但当我们执行到b = 2时，系统会重新创建一个值为2的新对象，并让b指向它；而a仍然指向1这个对象。所以，a的值不变，仍然为1。

那么对于上述例子的情况，是不是就没有办法改变a的值了呢？

答案当然是否定的，我们只需稍作改变，让函数返回新变量，赋给a。这样，a就指向了一个新的值为2的对象，a的值也因此变为2。

```
def my_func2(b):
	b = 2
	return b

a = 1
a = my_func2(a)
a
2
```

不过，当可变对象当作参数传入函数里的时候，改变可变对象的值，就会影响所有指向它的变量。比如下面的例子：

```
def my_func3(l2):
	l2.append(4)

l1 = [1, 2, 3]
my_func3(l1)
l1
[1, 2, 3, 4]
```

这里l1和l2先是同时指向值为\[1, 2, 3]的列表。不过，由于列表可变，执行append()函数，对其末尾加入新元素4时，变量l1和l2的值也都随之改变了。

但是，下面这个例子，看似都是给列表增加了一个新元素，却得到了明显不同的结果。

```
def my_func4(l2):
	l2 = l2 + [4]

l1 = [1, 2, 3]
my_func4(l1)
l1
[1, 2, 3]
```

为什么l1仍然是\[1, 2, 3]，而不是\[1, 2, 3, 4]呢？

要注意，这里l2 = l2 + \[4]，表示创建了一个“末尾加入元素4“的新列表，并让l2指向这个新的对象。这个过程与l1无关，因此l1的值不变。当然，同样的，如果要改变l1的值，我们就得让上述函数返回一个新列表，再赋予l1即可：

```
def my_func5(l2):
	l2 = l2 + [4]
	return l2

l1 = [1, 2, 3]
l1 = my_func5(l1)
l1
[1, 2, 3, 4]
```

这里你尤其要记住的是，改变变量和重新赋值的区别：

- my\_func3()中单纯地改变了对象的值，因此函数返回后，所有指向该对象的变量都会被改变；
- 但my\_func4()中则创建了新的对象，并赋值给一个本地变量，因此原变量仍然不变。

至于my\_func3()和my\_func5()的用法，两者虽然写法不同，但实现的功能一致。不过，在实际工作应用中，我们往往倾向于类似my\_func5()的写法，添加返回语句。这样更简洁明了，不易出错。

## **总结**

今天，我们一起学习了Python的变量及其赋值的基本原理，并且解释了Python中参数是如何传递的。和其他语言不同的是，Python中参数的传递既不是值传递，也不是引用传递，而是赋值传递，或者是叫对象的引用传递。

需要注意的是，这里的赋值或对象的引用传递，不是指向一个具体的内存地址，而是指向一个具体的对象。

- 如果对象是可变的，当其改变时，所有指向这个对象的变量都会改变。
- 如果对象不可变，简单的赋值只能改变其中一个变量的值，其余变量则不受影响。

清楚了这一点，如果你想通过一个函数来改变某个变量的值，通常有两种方法。一种是直接将可变数据类型（比如列表，字典，集合）当作参数传入，直接在其上修改；第二种则是创建一个新变量，来保存修改后的值，然后将其返回给原变量。在实际工作中，我们更倾向于使用后者，因为其表达清晰明了，不易出错。

## **思考题**

最后，我为你留下了两道思考题。

第一个问题，下面的代码中, l1、l2和l3都指向同一个对象吗？

```
l1 = [1, 2, 3]
l2 = [1, 2, 3]
l3 = l2
```

第二个问题，下面的代码中，打印d最后的输出是什么呢？

```
def func(d):
    d['a'] = 10
	d['b'] = 20

d = {'a': 1, 'b': 2}
func(d)
print(d)
```

欢迎留言和我分享，也欢迎你把这篇文章分享给你的同事、朋友，一起在交流中进步。
<div><strong>精选留言（15）</strong></div><ul>
<li><span>Jingxiao</span> 👍（100） 💬（3）<p>关于思考题：
第一题：
l2和l3是指向同一个对象，因为两者之间用等号赋值了，l1并不是，l1所指向的[1, 2, 3]是另外一块内存空间，大家可以通过id()这个函数验证

第二题：
输出的是{&#39;a&#39;: 10, &#39;b&#39;: 20}，字典是可变的，传入函数后，函数里的d和外部的d实际上都指向同一个对象
d[idx] = value语句改变了字典对应key所指向的值
</p>2019-06-17</li><br/><li><span>轻风悠扬</span> 👍（2） 💬（7）<p>老师，最后一个代码示例，如果我把l2 = l2 + [4] 换成 l2 += [4]，l1会变成[1,2,3,4].不明白l2 = l2 + [4] 换成 l2 += [4]有什么不一样的地方，有点小困惑

def my_func5(l2):
  l2 += [4]

l1 = [1, 2, 3]
my_func5(l1)
l1
[1, 2, 3, 4]</p>2020-05-10</li><br/><li><span>mercy</span> 👍（2） 💬（1）<p>对象的id能否理解为指针</p>2019-11-12</li><br/><li><span>古明地觉</span> 👍（88） 💬（8）<p>针对@小恶魔的问题，回复一下

python里面一切皆对象， 比如a=1。在java里面是int a = 1，相当于先声明了一个int类型的变量a，然后给这个变量赋值为1。但在python中，是先在内存中申请一份空间，存的值为1，然后再给这块空间贴上一个标签，叫变量a，因此python中变量实际上是一个便利贴，可以贴在任何地方。并且还可以通过值来推断出变量的类型，这一步是由解释器来完成的。所以python虽然不需要显式声明变量，但它其实是强类型语言。
def func(d):
    d[&#39;a&#39;] = 10
    d[&#39;b&#39;] = 20
    d = {&#39;a&#39;: 1, &#39;b&#39;: 2}


d = {}
func(d)
print(d)  # {&#39;a&#39;: 10, &#39;b&#39;: 20}

至于这里为什么会是这个结果，当我们将d传递给func的时候，其实func里面的d和外面的d指向的是同一片内存。相当于一开始d={},存放{}这份空间只有d这一个便利贴，但是func(d)的时候，这份空间又多了一个便利贴。尽管都叫d，但一个是全局变量d，一个是函数的参数d
当d[&#39;a&#39;] = 10和d[&#39;b&#39;]=20的时候，由于字典是可变类型，所以外面的d也被修改了，此时外面的d和函数里面的d都指向了{&#39;a&#39;: 10, &#39;b&#39;: 20}, 但是当d = {&#39;a&#39;: 1, &#39;b&#39;: 2}的时候，这是属于赋值。因此python会在内存中再开辟一份空间，空间存放{&#39;a&#39;: 1, &#39;b&#39;: 2}，然后让函数里面的局部变量d指向它，相当于将原本位于{&#39;a&#39;:10,&#39;b&#39;:20}上的便利贴撕下来，贴在了另一块空间。但这只是函数里面的d，对外面的d是没有影响的，所以外面的d依旧是{&#39;a&#39;: 10, &#39;b&#39;: 20}。</p>2019-06-14</li><br/><li><span>somenzz</span> 👍（24） 💬（0）<p>第一个比较简单，列表是可变对象，每创建一个列表，都会重新分配内存，因此 l1 和 l2 并不是同一个对象，由于 l3 = l2 表明 l3 指向 l2 的对象。

第二个 输出的结果应该是 {&#39;a&#39;: 10, &#39;b&#39;: 20} ，d = {&#39;a&#39;: 1, &#39;b&#39;: 2} 属于重新指向新的对象，并不改变原有的字典对象。</p>2019-06-14</li><br/><li><span>yshan</span> 👍（11） 💬（2）<p>首先更正下，需要先定义d={}。
然后，局部变量与全局变量的区别，函数内定义的d为全局变量，在没有关键字声明的情形下不能改变全局变量，由于字典可变，遵循可变则可变的原则，输出为{&#39;a&#39;: 10, &#39;b&#39;: 20}。
最后，看实验：
def func(d):
    print(id(d))
    d[&#39;a&#39;] = 10
    d[&#39;b&#39;] = 20
    print(id(d))
    d = {&#39;a&#39;:1, &#39;b&#39;:2}
    print(id(d))
    print(d)

d = {}
print(id(d))
func(d)
print(d)
print(id(d))

执行结果：
3072243980
3072243980
3072243980
3072244108
{&#39;a&#39;: 1, &#39;b&#39;: 2}
{&#39;a&#39;: 10, &#39;b&#39;: 20}
3072243980

</p>2019-06-16</li><br/><li><span>程序员人生</span> 👍（8） 💬（1）<p>第一题，用id（）打印出来后可以证明，l1和l2不是同一个对象，l2和l3是同一个对象。由于列表是可变的，所以l1和l2指向不同的内存区域。
第二题，做了一下修改，如下：
def func(d):
    d[&#39;a&#39;] = 10
    d[&#39;b&#39;] = 20
    d={&#39;a&#39;:1,&#39;b&#39;:2}

d={}
func(d)
print(d)

执行结果：
{&#39;a&#39;: 10, &#39;b&#39;: 20}

d = {&#39;a&#39;: 1, &#39;b&#39;: 2}应该是指向了新的对象


</p>2019-06-14</li><br/><li><span>Wing·三金</span> 👍（7） 💬（0）<p># C++

- 按值传递：拷贝参数的值构建新的变量传递到函数
- 按引用传递：把参数的引用（i.e. 地址）传递到函数

# Python

- 按赋值传递&#47;按对象的引用传递
- 凡是对对象本身进行的操作，都会影响传递的原对象；凡是生成了新对象的操作，都不会影响传递的原对象
- 正如【一个人可以死两次，第一次是肉体死去，第二次是当没人记得它的时候】，python 中如果有多个变量指向同一个对象，那么当删除一个变量时并不会真正删除其所指定的对象；只有当所有指定该对象的变量都被删除时，python 才会回收该对象所占用的资源
- 一般原则：对于不可变的数据类型，operator 等操作会返回新的对象，不会影响原对象；对于可变的数据类型，任何对【对象本身】的操作都会影响所有指向该对象的变量
- 补充上一条：e.g. 对于 list 而言，l += [1] 和 l = l + [1] 不同！前者是在 l 本身的末尾添加新元素，后者是在 l 的基础上添加新的元素并返回新的对象
- 在工程上，偏爱类似于上一条后者的作法——即通过【创建新的对象+将其返回】的作法，来减少出错的概率

# 思考题

1. l1 与 l2 不同，l3 与 l2 同；
2. 严格来说，如果没有上下文，这是一段错误的代码，因为没有预先定义 d 变量；不妨假设在第 6 行之前补充语句 d = {}，则输出结果为 {&#39;a&#39;: 10, &#39;b&#39;: 20}，因为 func 中前两行才是改变了对象的操作。而第 3 行只是将函数中的局部变量 d 指向了新的字典 {&#39;a&#39;: 1, &#39;b&#39;: 2}，但全局变量 d 仍然指向着刚刚被修改过的字典对象。</p>2019-06-16</li><br/><li><span>SCAR</span> 👍（5） 💬（0）<p>第一题：l2和l3指向同一个对象，l2和l1不指向同一个对象。这个题的关键要点是要了解list对象是没有“内存驻留”机制的，这点和整数对象对小于256的数采用的“内存驻留”是截然不同的，所以l1和l2不是指向同一对象。而l3=l2,这就是让l3指向l2指向的对象，很显然l3和l2指向的是同一个对象。
第二题：题目里的d = {&#39;a&#39;: 1, &#39;b&#39;: 2}应该是顶格的吧，估计是老师手误或是编辑器出问题了，不然没意义。如果是这样，print(d),输出应该是{&#39;a&#39;: 10, &#39;b&#39;: 20}。</p>2019-06-14</li><br/><li><span>自由民</span> 👍（3） 💬（0）<p>总结:Python中参数传递既不是传值也不是传引用，而是赋值传递，或传对象的引用。不是指向一个具体的内存地址，而是指向具体的对象。
如果对象是不变的，改变对象会新建一个对象，并将其中一个变量指向该对象，其它变量不变。如果对象是可变的，改变一个变量时，其它所有指向该对象的变量都会受影响。要想在函数中改变对象，可以传入可变数据类型(列表，字典，集合)，直接改变；也可以创建一个新对象，修改以后返回。建议用后者，表达清晰明了，不易出错。
思考题1:
l2与l3指向同一对象，与l1不同。
# 思考题1
 l1 = [1,2,3,4]
 l2 = [1,2,3,4]
 l3 = l2
 print(id(l1), id(l2), id(l3))
思考题2
{&quot;a&quot;:10, &quot;b&quot;:20}
课程的练习代码: https:&#47;&#47;github.com&#47;zwdnet&#47;PythonPractice</p>2019-10-03</li><br/><li><span>youaresherlock</span> 👍（2） 💬（0）<p>Python应该是共享传参</p>2020-06-29</li><br/><li><span>1cho糖糖</span> 👍（2） 💬（1）<p>遇到了下面一个问题

```
def demo1(array):
    array += [4, 5]
    return array


def demo2(array):
    array = array + [4, 5]
    return array


a = [1, 2, 3]
b = [1, 2, 3]

c = demo1(a)
print(&#39;a list is {}\nc list is {}\na is c :{}&#39;.format(a, c, a is c))  # True
# 输出结果
a list is [1, 2, 3, 4, 5]
c list is [1, 2, 3, 4, 5]
a is c :True

d = demo2(b)
print(&#39;b list is {}\nd list is {}\nb is d :{}&#39;.format(b, d, b is d))  # False
# 输出结果
b list is [1, 2, 3]
d list is [1, 2, 3, 4, 5]
b is d :False

# 函数内部为什么 array += [4, 5] 与 array = array + [4, 5] 对传入的列表影响结果不同
```</p>2019-11-03</li><br/><li><span>catshitfive</span> 👍（2） 💬（0）<p>第一题：本例中，对于列表对象而言，l1和l2是不同的对象，l3指向的是l2，属于同一对象；对于列表内的immutable元素对象而言，这三个列表指向的都是相同的对象
第二题 使用数据结构中内置的方法或者切片操作会直接修改可变元素的内容而保持内存地址不变，如果是二个对象直接操作，则会创建新对象，所以本例中变量指向的字典内容会被函数更新
对于一维列表可以浅拷贝保存数据，对于二维及以上的，应该用深拷贝保存数据才安全</p>2019-06-14</li><br/><li><span>KaitoShy</span> 👍（2） 💬（0）<p>1. l2和l3是一个，l1不是。可以通过id(l2),id(l1),id(l3)验证。
2. d不是没有初始化么。输出错误吧。如果在使用函数func(),将d初始化为d={},输出{&#39;a&#39;:10, &#39;b&#39;:20}.原因：前两个改变了对象的值。后面是创建了新对象赋值给了本地对象。</p>2019-06-14</li><br/><li><span>Jacky</span> 👍（1） 💬（0）<p>不可变对象，赋值给变量时，如果两个对象的值相同，则指向同一个对象。
两个变量指向同一对象，如果其中一个对象的值改变，则新建对象赋值给变量。
可变对象，赋值给变量时，如果两个对象的值相同，则指向不同对象。
两个变量指向同一对象，如果其中一个对象的值改变，两个变量的值都发生改变。（指向统一对象）</p>2021-01-25</li><br/>
</ul>