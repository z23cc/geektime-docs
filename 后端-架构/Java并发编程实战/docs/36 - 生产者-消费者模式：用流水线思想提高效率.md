前面我们在[《34 | Worker Thread模式：如何避免重复创建线程？》](https://time.geekbang.org/column/article/95525)中讲到，Worker Thread模式类比的是工厂里车间工人的工作模式。但其实在现实世界，工厂里还有一种流水线的工作模式，类比到编程领域，就是**生产者-消费者模式**。

生产者-消费者模式在编程领域的应用也非常广泛，前面我们曾经提到，Java线程池本质上就是用生产者-消费者模式实现的，所以每当使用线程池的时候，其实就是在应用生产者-消费者模式。

当然，除了在线程池中的应用，为了提升性能，并发编程领域很多地方也都用到了生产者-消费者模式，例如Log4j2中异步Appender内部也用到了生产者-消费者模式。所以今天我们就来深入地聊聊生产者-消费者模式，看看它具体有哪些优点，以及如何提升系统的性能。

## 生产者-消费者模式的优点

生产者-消费者模式的核心是一个**任务队列**，生产者线程生产任务，并将任务添加到任务队列中，而消费者线程从任务队列中获取任务并执行。下面是生产者-消费者模式的一个示意图，你可以结合它来理解。

![](https://static001.geekbang.org/resource/image/df/15/df72a9769cec7a25dc9093e160dbbb15.png?wh=1142%2A326)

生产者-消费者模式示意图

从架构设计的角度来看，生产者-消费者模式有一个很重要的优点，就是**解耦**。解耦对于大型系统的设计非常重要，而解耦的一个关键就是组件之间的依赖关系和通信方式必须受限。在生产者-消费者模式中，生产者和消费者没有任何依赖关系，它们彼此之间的通信只能通过任务队列，所以**生产者-消费者模式是一个不错的解耦方案**。

除了架构设计上的优点之外，生产者-消费者模式还有一个重要的优点就是**支持异步，并且能够平衡生产者和消费者的速度差异**。在生产者-消费者模式中，生产者线程只需要将任务添加到任务队列而无需等待任务被消费者线程执行完，也就是说任务的生产和消费是异步的，这是与传统的方法之间调用的本质区别，传统的方法之间调用是同步的。

你或许会有这样的疑问，异步化处理最简单的方式就是创建一个新的线程去处理，那中间增加一个“**任务队列**”究竟有什么用呢？我觉得主要还是用于**平衡生产者和消费者的速度差异**。我们假设生产者的速率很慢，而消费者的速率很高，比如是1:3，如果生产者有3个线程，采用创建新的线程的方式，那么会创建3个子线程，而采用生产者-消费者模式，消费线程只需要1个就可以了。Java语言里，Java线程和操作系统线程是一一对应的，线程创建得太多，会增加上下文切换的成本，所以Java线程不是越多越好，适量即可。而**生产者-消费者模式恰好能支持你用适量的线程**。

## 支持批量执行以提升性能

前面我们在[《33 | Thread-Per-Message模式：最简单实用的分工方法》](https://time.geekbang.org/column/article/95098)中讲过轻量级的线程，如果使用轻量级线程，就没有必要平衡生产者和消费者的速度差异了，因为轻量级线程本身就是廉价的，那是否意味着生产者-消费者模式在性能优化方面就无用武之地了呢？当然不是，有一类并发场景应用生产者-消费者模式就有奇效，那就是**批量执行**任务。

例如，我们要在数据库里INSERT 1000条数据，有两种方案：第一种方案是用1000个线程并发执行，每个线程INSERT一条数据；第二种方案是用1个线程，执行一个批量的SQL，一次性把1000条数据INSERT进去。这两种方案，显然是第二种方案效率更高，其实这样的应用场景就是我们上面提到的批量执行场景。

在[《35 | 两阶段终止模式：如何优雅地终止线程？》](https://time.geekbang.org/column/article/95847)文章中，我们提到一个监控系统动态采集的案例，其实最终回传的监控数据还是要存入数据库的（如下图）。但被监控系统往往有很多，如果每一条回传数据都直接INSERT到数据库，那么这个方案就是上面提到的第一种方案：每个线程INSERT一条数据。很显然，更好的方案是批量执行SQL，那如何实现呢？这就要用到生产者-消费者模式了。

![](https://static001.geekbang.org/resource/image/15/29/155d861702a047bd20b5708e06c6fd29.png?wh=1142%2A386)

动态采集功能示意图

利用生产者-消费者模式实现批量执行SQL非常简单：将原来直接INSERT数据到数据库的线程作为生产者线程，生产者线程只需将数据添加到任务队列，然后消费者线程负责将任务从任务队列中批量取出并批量执行。

在下面的示例代码中，我们创建了5个消费者线程负责批量执行SQL，这5个消费者线程以 `while(true){}` 循环方式批量地获取任务并批量地执行。需要注意的是，从任务队列中获取批量任务的方法pollTasks()中，首先是以阻塞方式获取任务队列中的一条任务，而后则是以非阻塞的方式获取任务；之所以首先采用阻塞方式，是因为如果任务队列中没有任务，这样的方式能够避免无谓的循环。

```
//任务队列
BlockingQueue<Task> bq=new
  LinkedBlockingQueue<>(2000);
//启动5个消费者线程
//执行批量任务  
void start() {
  ExecutorService es=executors
    .newFixedThreadPool(5);
  for (int i=0; i<5; i++) {
    es.execute(()->{
      try {
        while (true) {
          //获取批量任务
          List<Task> ts=pollTasks();
          //执行批量任务
          execTasks(ts);
        }
      } catch (Exception e) {
        e.printStackTrace();
      }
    });
  }
}
//从任务队列中获取批量任务
List<Task> pollTasks() 
    throws InterruptedException{
  List<Task> ts=new LinkedList<>();
  //阻塞式获取一条任务
  Task t = bq.take();
  while (t != null) {
    ts.add(t);
    //非阻塞式获取一条任务
    t = bq.poll();
  }
  return ts;
}
//批量执行任务
execTasks(List<Task> ts) {
  //省略具体代码无数
}
```

## 支持分阶段提交以提升性能

利用生产者-消费者模式还可以轻松地支持一种分阶段提交的应用场景。我们知道写文件如果同步刷盘性能会很慢，所以对于不是很重要的数据，我们往往采用异步刷盘的方式。我曾经参与过一个项目，其中的日志组件是自己实现的，采用的就是异步刷盘方式，刷盘的时机是：

1. ERROR级别的日志需要立即刷盘；
2. 数据积累到500条需要立即刷盘；
3. 存在未刷盘数据，且5秒钟内未曾刷盘，需要立即刷盘。

这个日志组件的异步刷盘操作本质上其实就是一种**分阶段提交**。下面我们具体看看用生产者-消费者模式如何实现。在下面的示例代码中，可以通过调用 `info()`和`error()` 方法写入日志，这两个方法都是创建了一个日志任务LogMsg，并添加到阻塞队列中，调用 `info()`和`error()` 方法的线程是生产者；而真正将日志写入文件的是消费者线程，在Logger这个类中，我们只创建了1个消费者线程，在这个消费者线程中，会根据刷盘规则执行刷盘操作，逻辑很简单，这里就不赘述了。

```
class Logger {
  //任务队列  
  final BlockingQueue<LogMsg> bq
    = new BlockingQueue<>();
  //flush批量  
  static final int batchSize=500;
  //只需要一个线程写日志
  ExecutorService es = 
    Executors.newFixedThreadPool(1);
  //启动写日志线程
  void start(){
    File file=File.createTempFile(
      "foo", ".log");
    final FileWriter writer=
      new FileWriter(file);
    this.es.execute(()->{
      try {
        //未刷盘日志数量
        int curIdx = 0;
        long preFT=System.currentTimeMillis();
        while (true) {
          LogMsg log = bq.poll(
            5, TimeUnit.SECONDS);
          //写日志
          if (log != null) {
            writer.write(log.toString());
            ++curIdx;
          }
          //如果不存在未刷盘数据，则无需刷盘
          if (curIdx <= 0) {
            continue;
          }
          //根据规则刷盘
          if (log!=null && log.level==LEVEL.ERROR ||
              curIdx == batchSize ||
              System.currentTimeMillis()-preFT>5000){
            writer.flush();
            curIdx = 0;
            preFT=System.currentTimeMillis();
          }
        }
      }catch(Exception e){
        e.printStackTrace();
      } finally {
        try {
          writer.flush();
          writer.close();
        }catch(IOException e){
          e.printStackTrace();
        }
      }
    });  
  }
  //写INFO级别日志
  void info(String msg) {
    bq.put(new LogMsg(
      LEVEL.INFO, msg));
  }
  //写ERROR级别日志
  void error(String msg) {
    bq.put(new LogMsg(
      LEVEL.ERROR, msg));
  }
}
//日志级别
enum LEVEL {
  INFO, ERROR
}
class LogMsg {
  LEVEL level;
  String msg;
  //省略构造函数实现
  LogMsg(LEVEL lvl, String msg){}
  //省略toString()实现
  String toString(){}
}
```

## 总结

Java语言提供的线程池本身就是一种生产者-消费者模式的实现，但是线程池中的线程每次只能从任务队列中消费一个任务来执行，对于大部分并发场景这种策略都没有问题。但是有些场景还是需要自己来实现，例如需要批量执行以及分阶段提交的场景。

生产者-消费者模式在分布式计算中的应用也非常广泛。在分布式场景下，你可以借助分布式消息队列（MQ）来实现生产者-消费者模式。MQ一般都会支持两种消息模型，一种是点对点模型，一种是发布订阅模型。这两种模型的区别在于，点对点模型里一个消息只会被一个消费者消费，和Java的线程池非常类似（Java线程池的任务也只会被一个线程执行）；而发布订阅模型里一个消息会被多个消费者消费，本质上是一种消息的广播，在多线程编程领域，你可以结合观察者模式实现广播功能。

## 课后思考

在日志组件异步刷盘的示例代码中，写日志的线程以 `while(true){}` 的方式执行，你有哪些办法可以优雅地终止这个线程呢？

```
this.writer.execute(()->{
  try {
    //未刷盘日志数量
    int curIdx = 0;
    long preFT=System.currentTimeMillis();
    while (true) {
    ......
    }
  } catch(Exception e) {}
}    
```

欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。
<div><strong>精选留言（15）</strong></div><ul>
<li><span>锦</span> 👍（140） 💬（1）<p>在应用系统中，日志系统一般都是最后关闭的吧，因为它要为其他系统关闭提供写日志服务。所以日志系统关闭时需要把队列中所有日志都消费掉才能关闭。
可能需要在关闭日志系统时投入一个毒丸，表示没有新的日志写入。线程池在消费到毒丸时知道没有日志写入，将所有的日志刷盘，break循环体。
</p>2019-05-21</li><br/><li><span>PK時頭髮不亂</span> 👍（49） 💬（4）<p>极客时间有好多课程, 我觉得王老师的干货是最实际最可用的, 必须要赞一个。</p>2019-05-21</li><br/><li><span>êｗěｎ</span> 👍（29） 💬（4）<p>
之前遇到过一个生产问题，一个服务启动一段时间后就不停的超时，后面结合线程栈发现很多阻塞在打印日志的地方（我们用的就是log4j2），后面查到机子硬盘问题，io直接100%以上，日志刷盘满导致消费速度慢，队列撑满阻塞了写，这间接说明平衡好生产和消费速度以及适当的队列大小是很有必要。</p>2019-05-22</li><br/><li><span>苏籍</span> 👍（14） 💬（1）<p>您好老师问个最近用到的线程池使用的问题
我的工程是springboot的，在unitTest里（@SpringBootTest） 里调用了一个service A（通过@Autowired的）中的方法，A中启用了一个线程池，执行的任务 是往数据库里插入数据。但是总抛出数据源已经被关闭的异常，我理解的是在单测主线程已经结束，所以关闭了数据源这些清理工作，而此时线程池的线程还
没结束，这个时候去调用数据源是null 的，不知道这么理解对不对，另外这个test主线程结束，为啥线程池的线程还没结束（通过打断点看到的）。这个怎么理解，求教</p>2019-05-22</li><br/><li><span>Asanz</span> 👍（12） 💬（1）<p>看到很多示例代码都没有关闭线程池的动作，难道局部的线程池就不要关闭吗？</p>2019-08-08</li><br/><li><span>生活发言权</span> 👍（9） 💬（3）<p>请问一下高并发场景，四个人拼一个团，怎么拼？
1.db里记录拼团人数，如果小于4则直接update到拼团用户表，否则创建新的拼团id，新的记录。
2.高并发场景，怎么保证读写db的一致性？redis和db双写？
3.期待老师高见</p>2019-09-18</li><br/><li><span>berthav_ss</span> 👍（8） 💬（1）<p>宝令老师，如何优雅的停止线程池中某一组线程呢？例如我在线程a中启动了1-10线程，线程b中启动了2-30线程，如何优雅停止1-10线程呢</p>2019-06-11</li><br/><li><span>来</span> 👍（5） 💬（1）<p>你好我想问下，生产者-消费者模式和worker thread模式有什么区别和联系？我看它们的核心都是任务队列，都是先把任务放到任务队列中，然后再从任务队列中获取任务并执行。</p>2020-06-03</li><br/><li><span>Geek_b38255</span> 👍（1） 💬（1）<p>老师你好，想请教下，生产者-消费者模式 与 Worker Thread 模式的区别是什么呢？</p>2021-05-01</li><br/><li><span>Monday</span> 👍（1） 💬（1）<p>第一段代码，非阻塞获取任务时，如果再单批次数量上限比如1000，是不是更好些</p>2020-12-23</li><br/><li><span>荷兰小猪8813</span> 👍（1） 💬（2）<p>如果使用轻量级线程，就没有必要平衡生产者和消费者的速度差异了，因为轻量级线程本身就是廉价的，

为什么廉价就不需要平衡？</p>2019-11-25</li><br/><li><span>Geek_0quh3e</span> 👍（1） 💬（1）<p>声明一个volatie变量用于表示线程结束，为true时，退出循环
</p>2019-05-21</li><br/><li><span>密码123456</span> 👍（1） 💬（1）<p>设置一个volitle  。这里中断设置不了，没有引用。我觉得一个volite关键字够了。之前说happens before的时候说，volit写，优于volit读，应该立刻可见。还要问下老师，这么理解可以吗？中断是不是一定必须的？</p>2019-05-21</li><br/><li><span>王藝明</span> 👍（0） 💬（1）<p>老师好！批量插入 SQL 的案例中，【首先是以阻塞方式获取任务队列中的一条任务，而后则是以非阻塞的...】下面的代码，感觉如果一直能取到内容，岂不是退不出循环体了</p>2019-08-02</li><br/><li><span>尔东橙</span> 👍（0） 💬（1）<p>宝令老师，现在大公司代码规范都是缩进两空格么？</p>2019-07-21</li><br/>
</ul>