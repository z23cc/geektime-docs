你好，我是姚琪琳。

上节课，我们学习了什么是遗留系统，对于老旧、过时，但又十分重要、不可替代的遗留系统，听之任之只会埋下隐患，真正出现问题就为时已晚了。

不过在动手改造遗留系统之前，我们先要找准方向。其实相比遗留系统“治理”、“改造”，我们更强调的是“现代化（Modernization）”，也就是把遗留系统变为现代化的系统。这也是国际上更通用的提法。用“Legacy System Modernization”这个关键词，在Google上能搜到1380万条结果。

很多团队在对遗留系统进行“改造”或者“现代化”的时候，往往会陷入一个误区，就是盲目引入各种时髦的新技术，仿佛“新”就代表着“好”，就代表着方向正确。

比如我们耳熟能详、近年来愈发流行的微服务架构，有些团队也不管自己的项目适不适合，上来就把一个“大泥球”式的遗留系统肢解成了几十个微服务。更有甚者，一个遗留系统拆成了几百个微服务，有些甚至一张表的“增、删、查、改”居然被拆成了四个服务。架构似乎“现代化”了，运维人员却“哭”了。

那遗留系统现代化的正确方向到底是什么呢？结合上节课的分析，遗留系统在代码、架构、测试、DevOps方面存在诸多问题，我们在此基础上，将代码和测试合并（因为它们说的都是代码的质量），并引入开发团队这个维度，就得到了遗留系统现代化的四个方向：**代码现代化、架构现代化、DevOps现代化和团队结构现代化**。

## 代码现代化

代码现代化顾名思义，就是把遗留系统中丑陋的“祖传”代码重构成职责清晰、结构良好的优质代码。

之所以说遗留系统中的代码是“祖传”的，是因为它和其他祖传的东西类似，都是历史悠久、且不敢轻举妄动的。而之所以不敢轻举妄动，就是因为缺乏测试，无法快速验证修改的正确性。而大多数情况下，之所以没有测试，又是因为代码写得不可测。可测试的代码和代码的测试是相互依存的，其中一个做到了，另一个也很容易做到，而如果其中一个没有做到，另一个也必然无法做到。

**因此代码现代化的首要任务，就是对遗留系统的代码进行安全的可测试化重构**。

在正常情况下，重构应该是在充分的自动化测试的保护下进行的。但对于没有测试的代码，我们只能“硬着头皮”去做一些相对来说比较安全的重构，将代码重构成可以写测试的程度，然后再补上大量的测试，进而在有充分测试覆盖的情况下，进行更广泛更深入的重构。

后面的课程我还会详细讲解如何进行可测试化重构，但在这里我想先举一个小例子，来让你有个感性认识。比如下面的代码，我想测试if的逻辑，当Dao的方法返回一个null时，这段代码会抛出一个异常。

```java
public class EmployeeService {
  public EmployeeDto getEmployeeDto(long employeeId) {
    EmployeeDao employeeDao = new EmployeeDao();
    // 访问数据库获取一个Employee
    Employee employee = employeeDao.getEmployeeById(employeeId);
    if (employee == null) {
      throw new EmployeeNotFoundException(employeeId);
    }
    return convertToEmployeeDto(employee);
  }
}
```

看到这样的代码，你可能会说，这质量还行啊，可读性不错，职责也比较清晰。的确是这样，但这样的代码却是不可测的。因为EmployeeDao内部会访问数据库，从中读取出一个Employee对象。而这个EmployeeDao是在方法内通过new的方式直接构造的，就意味着这个方法对EmployeeDao的依赖是固定的，无法解耦的。

要知道在单元测试中，我们是不可能直接访问真实的数据库的，因此要想测试这样的方法，只能先对它进行可测试化重构，也就是先将它重构为可测试的代码。

什么样的代码叫可测试的呢？比如下面这样：

```java
public class EmployeeService {
  private EmployeeDao employeeDao;
  public EmployeeService(EmployeeDao employeeDao) {
    this.employeeDao = employeeDao;
  }

  public EmployeeDto getEmployeeDto(long employeeId) {
    Employee employee = employeeDao.getEmployeeById(employeeId);
    if (employee == null) {
      throw new EmployeeNotFoundException(employeeId);
    }
    return convertToEmployeeDto(employee);
  }
}
```

通过这次重构，我们把会访问数据库的EmployeeDao提取成类的私有字段，通过构造函数传入到EmployeeService中来，在getEmployeeDto方法中，就可以直接使用这个EmployeeDao实例，不用再去构造了。由于传入的EmployeeDao并不是EmployeeService构造的，所以后者对前者的依赖就不是固定的，是可以解耦的。

如果我们传入EmployeeService的是一个new出来的EmployeeDao，那和原来的方法一样，仍然会去访问数据库；如果传入的是一个EmployeeDao的子类，而这个子类不会去访问数据库，那么getEmployeeDto这个方法就不会直接访问数据库，它就变成可测试的了。比如我们传入这样的一个子类：

```java
public class InMemoryEmployeeDao extends EmployeeDao {
  @Override
  public Employee getEmployeeById(long employeeId) {
    return null;
  }
}
```

这样，想测试原方法中if的代码逻辑就非常方便了。

这里我们使用的重构手法叫做**提取接缝（Extract Seam）**，至于什么是接缝，以及还有哪些可测试化重构的手法先按下不表，后面课里我会细说，你先有个初步印象就好。

当代码可测了，我们就可以为它们添加足够的测试，提供质量保障。然后，在测试的保障下进行安全的重构。接下来要做的就是将“祖传”代码重构得让人耳目一新。当代码结构良好了，再实现下一个代码现代化的目标，也就是良好的分层结构。

## 架构现代化

遗留系统现代化的第二个方向是架构现代化。看到“架构现代化”这几个字，有些同学很自然地就想到了微服务架构或云原生架构。然而我们前面说过，新不代表正确。在团队的开发能力、DevOps能力和运维能力不足的时候，引入微服务，反而会将团队推向更痛苦的深渊。

有时候我们常常把软件系统比作一个城市，把系统架构和城市建设做类比。随着城市的发展和扩张，以前处于城市边缘的农村，反而会被周围新建的高楼大厦包裹成为一个城中村。治理这些城中村，就叫“改造老城区”。

有时候老城区的设计和规划会暴露出一些问题，不足以满足城市的发展。比如市政府通过一些集中的招商引资后，很多企业都要来这里建厂，但老城区显然没有足够的空间。这时候很多城市都会新建一个城区，有些地方叫开发区，有些地方干脆直接就叫新区。我们将这称之为“建设新城区”。

同样，遗留系统的架构现代化，我们也可以分成“改造老城区”和“建设新城区”两类模式。

**改造老城区模式是指对遗留系统内部的模块进行治理、让模块内部结构合理、模块之间职责清晰的一系列模式。**前端方面包括单页应用注入、微前端等，后端包括抽象分支、扩张与收缩等，数据库端包括变更数据所有权、将数据库作为契约等。

![](https://static001.geekbang.org/resource/image/03/41/038a1616b382744261c92ed7945e0c41.jpg?wh=3840x1859)

**建设新城区模式是指将遗留系统内部的某个模块拆分到外面，或将新需求实现在遗留系统外部的一系列模式。**包括绞杀植物、冒泡上下文等。为了对新建立的新城区予以各种支持，老城区还可以通过提供API、变动数据捕获、事件拦截等各种模式，与新城区进行集成。

![图片](https://static001.geekbang.org/resource/image/63/21/63015b42d785dd8328ef1a618624d521.jpg?wh=1920x992)

看到这么多专业名词，你可能应接不暇，别担心，后面课里这些内容都会详细展开。总之，只有“改造老城区”和“建设新城区”齐头并进，遗留系统架构的现代化版图才算完整。

## DevOps现代化

代码和架构现代化了，DevOps的现代化也不能落后。它对项目的重要性不言而喻，如果没有现代化的DevOps平台，代码和架构现代化所带来的优势，就无法淋漓尽致地体现出来。

假如在代码和架构优化后，需求的开发时间缩短了一倍，那么大家对于新需求上线的时间点自然也有新的期待。然而落后的DevOps水平反而会让这个时间变得更长，因为单体架构变成微服务了，DevOps的难度增加了。

DevOps的历史虽然只有短短十几年，但最近几年的发展势头却很足。大大小小的公司都开始了DevOps转型，很多项目都声称自己建立了持续集成流水线，但实际上很多都是只见其形不见其神，只学其表不学其里。

而遗留系统的状况就更惨不忍睹了，它们几乎没有任何的自动化，或仅仅是一两句简单的构建命令。像我在第一节课里举的例子那样，在开发机上打包、靠人工用移动硬盘部署的项目还比比皆是。因此，遗留系统的DevOps现代化与其说是一种改进，不如说是从0到1的建设。这一部分可以和代码、架构的治理并行，甚至可以更早。先把平台搭起来，再逐步往上添加内容。对于大多数遗留系统来说，有一个可以对代码进行构建、打包的流水线，就已经是极大的进步了。

要从头开始搭建一个DevOps平台，包括代码、构建、测试、打包、发布、配置、监控等多个方面。这其中的代码和测试有一部分是和代码现代化重叠的，代码现代化的课里我会一并说给你听。剩下的几个部分再专门用一节课来详细讲述。

## 团队结构现代化

如果说代码、架构和DevOps的现代化还好理解的话，那这个团队结构现代化是个什么东西？其实很多时候，一个开发团队的结构是否合理，决定了这个团队的交付效率、产品质量，甚至项目成败，而很多人还没有对此产生足够的重视。

近年来有一本新书，叫做Team Topologies，中文直译就是团队拓扑。一上市便引起了不小的轰动。它将团队放到了软件开发的第一位，提出了四种团队拓扑结构和三种团队交互模式。四种团队拓扑包括业务流团队、复杂子系统团队、平台团队和赋能团队。三种团队交互模式包括协作、服务和促进。我们在进行开发团队的组织结构规划时，应该参考这四种团队拓扑。去年这本书的中文版——《高效能团队模式》也已经上市了。

我们对于团队结构的现代化，基本上是围绕这本书的内容展开的。因为我发现，遗留系统中团队的问题，有时比遗留系统本身更大。比如很多遗留系统可能只有一两个人在维护，在他们遇到困难的时候根本得不到团队的支持；再比如一些遗留系统的“老人”对系统比较熟悉，因此任何新启动的专项治理小组都会邀请他们加入，导致这些人的变动十分频繁，上下文切换的成本极其高昂。

团队拓扑不仅对遗留系统至关重要，对一个新系统如何组建开发团队、团队之间如何沟通协作也是至关重要的，后面我专门用一节课为你详细展开。

## 小结

今天我们学习了遗留系统的四个现代化。

也许你已经发现了，这样做本质上就是**将先进的、现代化的软件开发方法应用到遗留系统上**，让遗留系统重获新生、保持活力。是的，日光之下并无新事。遗留系统之所以成为遗留的，就是因为既缺乏现代化的软件开发方法，又没有随着潮流的发展而不断演进。  
![](https://static001.geekbang.org/resource/image/c2/e4/c2c9b09b10109abec6189df04a8b5ee4.jpg?wh=9470x7437 "遗留系统的四个现代化")

遗憾的是，这里还应该引入一个“需求现代化”，但是在权衡之后我将它删除了。因为一个企业里的需求方与开发方是不同的部门，要想进行需求的现代化，必然要让需求部门参与进来。然而国内很多企业的需求部门和开发部门，还无法亲密无间地展开合作。我们甚至有信心对开发部门内部的团队结构进行重组，但却没信心让需求人员改变工作习惯。

无论如何，在做到代码、架构、DevOps、团队结构四个现代化之后，遗留系统的现代化之路就算基本成功了。不过，在着手对这四个方面进行治理之前，我们还需要先掌握遗留系统现代化的三个原则。即：

1.以降低认知负载为前提  
2.以假设驱动为指引  
3.以增量演进为手段

这是我在工作中总结出来的，我们在遗留系统现代化中的许多举措，都符合这三个原则。忽视了它们，四个现代化之路很可能背道而驰。[下节课](https://time.geekbang.org/column/article/507513)我们就从修改需求的场景出发，聊一聊为啥要遵循“以降低认知负载为前提”这个原则。

## 思考题

感谢你学完了这节课的内容，今天的思考题是这样的：

你所在的遗留系统架构是什么样的？如果是单体架构，是否打算将其拆分为微服务？打算怎么拆？如果是分布式架构（不一定是微服务），是如何运维的？

欢迎你在留言区留下你的思考，我们一起交流讨论。
<div><strong>精选留言（15）</strong></div><ul>
<li><span>术子米德</span> 👍（6） 💬（1）<p>🤔☕️🤔☕️🤔
* 📖：现代化（Modernization），把遗留系统变成现代化的系统（Legacy System Modernization）
    * 🤔：现代化，到底是一个目标，还是一个过程？为何代码不能在第一天就现代化？我们今天写的代码能持久保持现代化嘛？如果一份代码，从开始到现在，都是一个开发在维护，需要现代化嘛？如果一份代码，至始至终都是流动的状态，有可能现代化嘛？到底是怎样的发心，能够持久呼喊系统现代化，为何我身边没有这样极度追求者？这些困惑和现状，在我心里似乎还是乱序的状态。我得想办法找出一个关键词，能够随时召唤出来，点亮我对于重构遗留系统的核心要义。就像代码评审，我给自己设定的关键词就是“易读性”，代码字面意思易读、代码业务含义易读、代码验证思路易读。可是，遗留系统重构，我还在寻找这样点亮我的关键词。
* 📖：遗留系统现代化四方向：代码现代化、架构现代化、DevOps现代化、团队结构现代化。
    * 🤔：现代化代码和古董级代码的关键差异，在于代码本身是否具备可测性。而可测性的关键区别点，就在于改动后，能否在【独立可控条件下验证修改】是否符合预期。难以独立验证，只能整体测试，那是能力问题。如果具备独立可控验证，还选择整体测试，要么认知不到位，要么就是态度问题，不客气说就是职业底线偏低。这样的底线下沉，并非开始如此，每个小地方，稍微懒惰一点，积累起无可挽救的自己。说起来容易，认识起来也容易，如何能让自己真正做到，就像每次带上红领巾，都会撸正每个角，这是天赋异禀，还是刻意可习得的优质。这个困惑，在我心头从未消除。即使我知道要撸正红领巾，可是我就会出现不撸正的时候，至于如此嘛，何以如此呢？这是自己呆在遗留团队太久，还是仅凭自己，就是不可能爬不出遗留系统的坑，怎么能找到棒喝自己的时机？
* 遗留系统现代化三原则：降低认知为前提、假设驱动为指引、增量演进为手段。
    * 🤔：降低认知，就像走路要穿鞋，否则必定走不远。假设驱动，就像爬山要地图，否则迟早迷路。增量演进，就像游泳要有换气频率，否则不是憋伤就是憋傻。
</p>2022-05-04</li><br/><li><span>aoe</span> 👍（3） 💬（3）<p>遗留系统现代化的三个原则：
1. 以降低认知负载为前提 
2. 以价值驱动为指引
3. 以增量演进为手段

关于团队结构现代化的一本书《Team Topologies》中文版《高效能团队模式》

我们的系统
微服务（SpringBoot）：20+ 
通信：Dubbo + RocketMQ
运维
- 使用 Jenkins 打包部署
- 测试环境：K8S
- 生产环境
  --业务线一：阿里云 serverless
  --业务线二：阿里云 K8S
  --业务线三：AWS K8S</p>2022-04-15</li><br/><li><span>escray</span> 👍（2） 💬（1）<p>我觉得三原则很棒，降低认知负载、价值驱动、增量演进，其实很多系统开发也应该遵循这样的原则。

另外就是遗留代码四个现代化里面，团队结构现代化是不是应该放在最前面？如果指望研发团队去做代码和架构现代化，感觉有点无从下手，我猜测平台团队和赋能团队应该可以做一些示范性的工作。

对于那个 InMemoryEmployeeDao 我也有点疑问，是不是可以考虑行为测试，使用 Mock 工具。

手头的项目是 C++ 开发的桌面应用，似乎对于单元测试的引入不那么友好。</p>2022-04-13</li><br/><li><span>Lee</span> 👍（0） 💬（1）<p>刚来这家公司，虽然有用阿里云，但是个人感觉基建还是有待提高，对于服务的划分在按照使用者，其次前端nodejs层承接过多业务含义，交互和体验上面前端关注度不太够，后端分层存在比较大的问题，因为存在中台，每次都参考中台的表设计之类，一问中台也是这样设计，对于圣经真的不是作为思想指导去灵活应用，而是必须把圣经定律搬进来，稍微有那么一点心累哈哈哈，如果我来重构，新起一个服务，在服务中按照不同领域进行分层，领域层之间步互相调用，如果需要聚合，单独一层来聚合或者处理，后面拆成微服务的话也很easy，之所以还是考虑新加一个服务还要审核，不一定能通过，这个也是组织结构的问题，也需考虑sre团队的成本</p>2022-07-24</li><br/><li><span>拉欧</span> 👍（0） 💬（1）<p>认知负载改成认知成本比较好</p>2022-05-21</li><br/><li><span>克劳斯</span> 👍（0） 💬（2）<p>请教老师，应该怎么定义现代化架构，衡量的标准是什么？先抛开遗留系统来讲，如果是一个全新搭建的系统，怎么判断系统上线后是不是遗留系统？文中提到的更多的是遗留系统现代化的原则，以及已有遗留系统架构现代化的模式和方法。</p>2022-05-15</li><br/><li><span>peter</span> 👍（0） 💬（2）<p>请教老师几个问题：
Q1：devOps就等于CI+CD吗？
Q2：InMemoryEmployeeDao只是测试用的，并不是业务代码，对吗？
Q3：上一课(01讲)，提到“付费软件从非官方渠道下载”，既然花钱买了，肯定会从官网下载啊，怎么会不从官网下载呢？
Q4：上一课(01讲)，提到“java开发的C&#47;S项目”。用java开发C&#47;S项目，这个决策本身就有问题吧。C&#47;S项目一般是桌面软件，桌面软件不是Java擅长的，而应该用微软那一套吧。</p>2022-04-13</li><br/><li><span>Anita</span> 👍（0） 💬（1）<p>我所在的遗留系统已经由单体拆成了微服务。为了和老系统一致，需要很多人工验证的工作，投入产出不高。</p>2022-04-13</li><br/><li><span>Anita</span> 👍（0） 💬（1）<p>老师，需求现代化能否再加上呢？了解了需求现代化开发人员可以给外部门提建议</p>2022-04-13</li><br/><li><span>MaLu</span> 👍（1） 💬（0）<p>1. 以降低认知负载为前提  -- 其实就是清晰化的
2. 以假设驱动为指引 -- 就是演绎逻辑、就是提前做试验的方法
3. 以增量演进为手段 -- 一是兼顾前后新旧 一是避免冒进冒失</p>2023-02-07</li><br/><li><span>小菜鸟</span> 👍（1） 💬（0）<p>对于可测试的重构可以采用mockito等mock框架，可以减少一些不好测试而改变代码结构的方式</p>2022-06-10</li><br/><li><span>苜蓿°</span> 👍（0） 💬（0）<p>如果作者还有机会更新，还是想听一下需求现代化是什么样子的，这样才更完整。</p>2024-12-23</li><br/><li><span>Jaising</span> 👍（0） 💬（0）<p>现有系统就是一个庞大的分布式系统，虽然架构团队设计了一套架构设计与交互规范，但是动辄上百的服务还是会牵扯众多的研发和运维同事参与。服务以组件形式提供，组件按照通信规范交互，有负责架构描述的、有负责基础组件的、有负责通用业务的、有面向应用的，并有一套较完备的定义、发布、维护机制。

问题在于这是基于私有云部署的架构，分布在各个项目的系统没法保证都拥有同样水准的运维人员，因此就会出现一类运维人员负责所有项目的一类组件，这就容易只看到组件而忽视系统，在系统不断升级的过程中依然是一个考验。</p>2024-09-13</li><br/><li><span>InvisibleDes</span> 👍（0） 💬（0）<p>看着感觉好抽象呀</p>2024-05-30</li><br/><li><span>fliyu</span> 👍（0） 💬（0）<p>改造老城区，建设新城区，任重道远</p>2023-01-31</li><br/>
</ul>