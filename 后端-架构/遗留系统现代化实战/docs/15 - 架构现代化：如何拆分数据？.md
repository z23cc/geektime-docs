你好，我是姚琪琳。

前面我们用四节课的篇幅，学习了架构现代化中，新老城区建设的种种模式。今天我们就来看看如何拆分数据，这个场景在建设新老城区，甚至与其他城市（外部系统）交互时都非常重要。

作为开发人员，你理想中的业务数据存储方式是什么样呢？当然是负责一个业务的数据都在一张或几张名称相关的表中，这样通过名称我们就可以一目了然，查找起来很方便。

不过很遗憾，现实有时候总是事与愿违，遗留系统中负责处理一个业务的数据，有的放在这张表，有的放在那张表，总是不在一起，名称甚至都没关系；而一张表中也有可能存放几种业务的数据。要想治理遗留系统的数据，就需要对这些数据加以拆分、重组，今天我们就来聊聊拆分、重组涉及到的各种模式。

## 共享数据库

如果你问我，拆分数据的第一个模式是什么？我的回答就是：不要拆分。

不拆分真的可行么？这需要先分析一下拆分的必要性。遗留系统的数据拆分是个认知负载非常高的工作，不同的数据混杂在一起，具有不同业务含义的数据也往往存放于一张表中，要想彻底拆分干净十分不容易。

如果你不需要不停机更新（大多数企业的业务系统其实都不需要）、没有严苛的可用性和弹性需求，或者数据量没有大到无法接受的程度，就没有必要拆分数据库。

这时，**共享数据库（Shared Database）也是一个可以接受的选择。我在[第十二节课](https://time.geekbang.org/column/article/515274)分享了基于服务的分布式架构**，就是一种共享数据库的分布式架构。

![图片](https://static001.geekbang.org/resource/image/91/6b/910e51dc730d7fba4e2c753d7f2bd26b.jpg?wh=1920x1090)

共享的数据分成两种情况。第一种是不同的服务访问同一数据库的不同Schema，第二种是不同的服务访问同一数据库的同一Schema。

第一种情况相当理想，因为不同业务领域的数据在逻辑上是隔离的，数据的所有权非常清晰。一个服务如果想访问其他服务的数据，在发现Schema不同后，一般不会跨Schema去读表，而是通过代码依赖或者数据库视图来访问。

第二种情况要差一些，所有模块都可以随意访问任意的表，操作这些数据的业务逻辑散落在各个服务中，你很难知道一张表到底归谁所有。

正如Sam Newman所说，一个服务，不管是粗粒度的领域服务还是微服务，都可以看成是行为和状态的组合，它封装了一个或多个状态机。这些状态其实就是数据，如果改变这些数据的行为分散在系统的不同位置，你其实很难正确实现这个状态机。

对于第二种情况，你应该尽量避免，或者只是作为一个过渡阶段，最终仍然要按逻辑或者物理的方式来隔离不同的数据。

## 数据库视图

还有一种场景，外部系统需要连接你的数据库来读写它所需要的数据，这里要你要绝对避免共享数据库。因为在这种情况下，数据的所有权将不再仅属于当前系统，不同的团队都能随意修改数据，很快就会变得混乱不堪，不同系统间的集成也会成为大问题。

这时你可以采取的一种方式是，为不同的外部系统创建不同的Schema，在Schema中提供**数据库视图（Database View）**，这些视图访问主Schema中的表。这样一来，外部系统就能以只读的方式访问你的数据了。

由于视图提供的是全部数据的一个有限的子集，外部系统只能访问你想让它访问的数据，比如部分表以及表中的部分字段，其他数据得以隐藏。这样就能最大程度地避免数据所有权的模糊。

![图片](https://static001.geekbang.org/resource/image/d2/a2/d24eea29cf9d339759fece1784a38fa2.jpg?wh=1920x1090)

## 数据库包装服务

可以访问数据库视图的，不仅仅是外部系统，还可以包括气泡上下文中的基于防腐层的仓库。但视图的方式只能提供只读数据，如果外部系统希望写入数据，应该如何处理呢？

你可以对数据库进行一层薄薄的封装，形成一个服务，将数据库的细节隐藏在这个**数据库包装服务（Database Wrapping Service）**之后，将数据库依赖转换成服务依赖。通过在数据库外放置一个明确的包装层，你可以很清楚地知道哪些数据是属于你的，哪些数据是别人的。

![图片](https://static001.geekbang.org/resource/image/a0/ec/a070bc0d65d899c07af0c6c0b5074aec.jpg?wh=1920x1090)

如果你的系统是基于Web的，你甚至可以在原系统之中去开发这个包装服务。但我还是建议你，最好把它当做一个气泡上下文，去开发一个全新的服务，不要让本就混乱的遗留系统雪上加霜。如果你的遗留系统不是基于Web的，那就更推荐使用这种模式了。

数据库包装服务除了可以提供写能力外，在读能力上也比数据库视图更灵活。你提供的并不局限于一张表或表中的部分字段，还可以提供更加复杂的数据映射。

这种包装服务看似很薄，但它也可以作为一个中间步骤，为后续更深入的数据拆分打下基础。

## 报表数据库

如果你的外部系统或气泡上下文是一个报表系统或服务，需要读取大量的数据，数据库包装服务的方法就不太适用了。因为这个包装服务的所有权是你的，而不是外部系统的，它们无法灵活地定制查询。

而数据库视图也有点力不从心，因为业务数据和报表的流量都压在一个数据库上，这显然不是你想看到的。

更好的方式是使用**报表数据库（Reporting Database）模式**，它会为报表这类只读的服务单独构建一个数据库。

这个数据库可以是业务数据库的远程复本，也可以是一个完全不同的、更适合报表的数据结构（如大宽表），并通过某种方式来做数据的转换和映射。对于后一种实现，你可以使用与业务数据库完全异构的数据库，这样更加灵活。但它也带来了一定的开销，就是你需要自己去实现一个数据映射的工具。

![图片](https://static001.geekbang.org/resource/image/7c/12/7c66ffa33c8ced5da6766e0d08275712.jpg?wh=1920x1090)

报表数据库模式有时也叫做**数据库即服务接口（Database-as-a-Service Interface）**，因为这种思想已经远远不止用于报表这个单一场景了。随着大数据的兴起，很多数据项目也使用类似的方式，将业务数据映射到数据仓库或数据湖中，再由数据流水线去进行处理。

## 变更数据所有权

到目前为止，我们学习的四种模式，都是基于一个共享的数据库，并没有涉及到拆分数据库这个真正棘手的问题。之所以先讲四种共享数据库模式，是想让你知道，在不拆分数据库的情况下，你也有一些方案可以选择。

如果要拆分数据，最简单的场景就是在基于服务的分布式架构中，不同服务访问单体数据库中的不同Schema。因为不同业务领域的数据已经由Schema隔离开了，你只需要少量改动，就可以将不同Schema中的数据迁移到单独的数据库中。

如果不同服务访问的是单体数据库中的相同Schema，就会麻烦得多，因为数据并没有从逻辑上进行隔离。但简单的情况怎样处理，我们已经知道了，那稍微复杂一些的情况就好办了，只要把它转换成简单的情况就可以了。所以我们只需要把同一Schema下的数据，用Schema隔离开。

那新的问题就来了，怎么隔离呢？不同的领域服务访问的表都是交织在一起的，根本不知道哪些表属于哪个领域服务或组件。

其实，你可以回忆一下[第十二节课](https://time.geekbang.org/column/article/515274)的内容，如果组件之间边界不明显，我们可以使用**战术分叉**的方式将“拆”变为“删”。其实数据拆分也是一样的，你也可以将整个Schema复制一份，在新的Schema中删除相应的领域服务没有访问到的表，剩下的就是与领域服务有关的所有表了。

![图片](https://static001.geekbang.org/resource/image/72/30/723deedaf3e552f032f73eb93874a730.jpg?wh=1920x1090)

接下来，我们再对访问的表做个分组处理。需要依据的原则是，**谁写数据谁就拥有这张表。**因此，我们可以把执行写操作的表，当作是真正归属于当前领域服务的，保持不动即可；而只读的表应该归其他领域服务，所以我们可以把这些表调整成视图。

如果目标是拆分Schema，到这一步就差不多结束了。但如果目标是独立的数据库，你还要在独立的数据库中将这些视图转换为表，将原数据库中的数据冗余到新库中，并通过**CDC**和**事件拦截**等方式同步数据。

如果不想冗余数据，你还可以**将连表查询转换为API调用**。具体来说就是，拆分新库和老库中不同表的连表查询，提取出新库的查询，在单体或其他领域服务中把老库的表封装成API。然后在独立出来的领域服务中，把新库的数据和调用API得到的数据组装起来。

在封装老库的API时，你可以使用**数据库包装服务模式**，也可以使用更加开放的**聚合API模式**。后者不像前者那样只提供基础的CRUD服务，而是将一个聚合的所有操作都暴露为API。

比如在订单服务中，下完一个订单后，会连带着对库存表进行操作。用数据库包装服务的话，库存服务就会封装一个修改库存表的API，而聚合API则会提供一个减库存的API。两者乍看上去似乎差别不大，但其实体现出了完全不同的封装策略。

这种将混杂在一起的数据拆分出来，各自归属各自服务的过程，叫做**变更数据所有权（Change Data Ownership）**。

在这个过程中，我们有的时候是在A中先查出数据，然后调用B得到B的数据，然后在A中进行组合；有的时候是在A中查出部分数据，根据这些数据去调用B，得到最终结果。到底怎么调用其实不重要，只要数据的所有权划分清楚了就好。

## 在应用中同步数据

在拆分数据的时候，你的出发点可能并不是解耦，而是想换一个更加合适的数据库，来解决特定的问题。比如社交领域中的好友关系，你可能想用图数据库来替换关系型数据库，来得到更好的查询性能。

我建议你先拆再换，而不要想着一次性连拆带换。我们做遗留系统现代化这种高认知负载的任务，尤其要记住的一点就是，一次只做一件事，将认知负载降到最低。

那么当数据库拆分出来之后，如何切换到异构数据库呢？我这里教给你一个比较稳妥的办法——**在应用中同步数据**。让我们来看看它的增量演进方案，一共分四步。

第一步，批量地复制数据。如果老库在业务上是允许停机的，可以直接停机导数据。如果不允许停机，在复制数据的过程中会产生新的数据。这就需要通过CDC等方式来保证这部分变动也能同步到新库中。

第二步，同时写入新旧两个库，但只从旧库中读数据。由于新库刚刚部署不久，很可能会出问题，所以我们要在应用程序中“**双写**”新旧两个库，以确保两个库中都有同样的业务数据。一旦新库出现问题，业务也不至于受影响。

第三步，同时写入新旧两个库，但只从新库中读数据。当我们对新库的基础设施有了信心之后，就可以把读操作也转移到新库中。这时我们仍然双写数据，因此出现任何问题都可以回退。

第四步，当新旧两库同时运行一段时间后，我们对新库的方方面面都有了十足的信心，此时就可以删掉旧库（或Schema），彻底迁移到新库中了。

除了做异构数据库的迁移，这种方式也同样适用于拆分微服务时的数据解耦。为了保证拆分数据的正确性，在增量演进的时候，也必然需要保证新旧两个库的数据同步。在同步时，由于有开关的存在，因此我们需要在新旧系统中都实现数据的双写。

除此之外，该模式也可以用于先拆数据再拆服务的情况。我们拆分服务的时候，有时会先拆代码，再拆数据库，有时则反之，先拆数据库再拆代码。你一定困惑了吧，如果是你，该怎么选择呢？

## 先拆代码还是先拆数据库？

如果我们的目标是微服务架构，那么只有代码和数据库都拆分出来且独立部署了，整个任务才算结束。因此拆分工作，你就有三种顺序可选：先拆数据库、先拆代码或同时拆分。

拆分数据库（包括拆分成单独的库或拆分出新的Schema），意味着以前的事务性操作会变成非事务的，你需要访问新旧两个库，然后在代码中对数据进行集成。这会造成新旧两个库的不一致。

虽然早晚都会遇到这样的问题，但我仍然建议你先拆分代码，因为拆分代码的认知负载相对低一些，采用战术分叉的方式拆分，也会更简单。

这能让你快速得到一些短期收益，比如代码的解耦、服务的独立部署。而且从单体到基于服务的分布式架构这条演进路线，也是十分清晰和成熟的。你可以随时停止，随时重启。

而数据库拆分则要困难得多，一旦先拆数据库，又发现很长时间看不到收益，团队的士气会严重受挫。

不过无论如何，我都不建议你同时拆分。一次只做一件事，是我们的原则。有些架构师可能还希望在拆分数据库的同时重新设计数据库，增加或修改一些表，我通常都建议他们不要贪心，保持克制，尽量先拆再改。

一次做多件事，任务的范围会越来越发散，导致最终迷失方向，忘了初心。遗留系统本身就是认知负载非常高的系统，不要再人为地增加认知负载了。

## 小结

又到了总结的时候。今天我们学习了拆分遗留系统的数据时，可以选用的一系列模式，结合前面课程里讲过的一些内容，我特意为你总结了两张表格用于回顾重点。

第一张表是在拆分数据库时，可用于数据同步的几种模式：

![图片](https://static001.geekbang.org/resource/image/16/ab/16aa52e4b4fc30f2dbd92f5d0eb31cab.jpg?wh=1920x797)

第二张表是在拆分服务时，可用于数据共享的几种模式：

![图片](https://static001.geekbang.org/resource/image/00/8a/001167da9423818eb78e813266f5158a.jpg?wh=1920x1070)

数据库的解耦，是我们无论如何都会面对的问题，也是架构现代化中最困难最复杂的部分。很多时候，代码的拆分其实就相当于数据的拆分。希望你能牢记这些模式，用它们指导你的日常工作。

到此为止，我们用五节课的时间学习了架构现代化的种种模式，相信它们可以指导你对遗留系统的前端、后端、架构和数据进行演进。[下节课](https://time.geekbang.org/column/article/518816)，我们一起来聊聊DevOps现代化相关的内容，敬请期待。

## 思考题

感谢你学完了今天的内容，今天的思考题是这样的，请你分享一下你在项目中拆分数据库的过程，是否使用了我前面讲到的某些模式？整个过程是否是增量演进的？

期待你的分享，如果你觉得这节课对你有帮助，别忘了分享给你的同事和朋友，我们一起拆分数据库。
<div><strong>精选留言（6）</strong></div><ul>
<li><span>aoe</span> 👍（4） 💬（1）<p>一次只做一件事这个原则非常实用，是一个解决遗留系统的神器！

当初接到了优化赠送礼物接口的任务（四种不同的场景，功能各有千秋，就像火锅的四种不同锅底，没人关心底料的配方，好吃就行）：
1. 第一次（一年前）信心满满的尝试分析所有场景，准备抽取公共部分。结果只提取了一小段，没有功能测试做保障，改不动；
2. 第二次（现在）由于业务量增加，频出问题，简单粗暴的选择了出问题最多的那个场景进行改造，虽然仍旧复杂，但看的到希望，不像第一次被众多的功能压垮
3. 今天学习了老师的文章才明白：这就是一次只做一件事的威力！</p>2022-05-19</li><br/><li><span>chon</span> 👍（0） 💬（1）<p>老师请教一下，数据拆分有一个场景就是由于数据量大了，需要分库分表。貌似如何拆分数据这章节没提到怎么做。是不是也是和异构数据库的套路一样？如果讨论是一样的话，有没有什么和异构数据库不一样，需要特别注意的地方？</p>2022-05-25</li><br/><li><span>子夜枯灯</span> 👍（0） 💬（1）<p>报到，报道。老师拆分数据库后的事物问题，如何处理？拆分Schema，基于原有数据表上横向拆分和纵向拆分有哪些优缺点需要提前规划呢？</p>2022-05-13</li><br/><li><span>实习工程师</span> 👍（1） 💬（0）<p>第三步，同时写入新旧两个库，但只从新库中读数据。当我们对新库的基础设施有了信心之后，就可以把读操作也转移到新库中。这时我们仍然双写数据，因此出现任何问题都可以回退。</p>2022-10-12</li><br/><li><span>实习工程师</span> 👍（0） 💬（0）<p>第三步，同时写入新旧两个库，但只从新库中读数据。当我们对新库的基础设施有了信心之后，就可以把读操作也转移到新库中。这时我们仍然双写数据，因此出现任何问题都可以回退。

老师， 这里好像有点不通畅， 应该是先读旧库，对新库有信心了再切换读新库？</p>2022-10-12</li><br/><li><span>雨落～紫竹</span> 👍（0） 💬（0）<p>当需求量上来后 这些都只能是技术债了</p>2022-07-04</li><br/>
</ul>