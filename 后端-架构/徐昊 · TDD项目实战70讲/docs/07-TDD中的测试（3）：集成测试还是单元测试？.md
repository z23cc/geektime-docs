你好，我是徐昊。今天我们来继续学习测试驱动开发中的测试。

上节课我们介绍了行为验证，以及为什么它不应该是TDD的主要验证方式，而应该尽可能地采用状态验证。至此，我们介绍完了测试驱动开发中测试的基本结构，及其主要的验证方法。

有了这些做基础，我们再来讨论一下测试驱动中测试的性质，以及为什么称呼它为“单元测试”是一种误解。

## 集成测试还是单元测试？

首先请回忆[第一讲](http://https://time.geekbang.org/column/article/494207)中的视频演示，我们从功能出发，分解出来的第一个驱动开发的测试，是针对布尔选项的测试：

```
//ArgsTest

@Test
public void should_set_boolean_option_to_true_if_flag_present() {
  BoolOption options = Args.parse(BooleanOption.class, "-l");
  assertTrue(options.logging());
}

static record BooleanOption(@Option("l") boolean logging);
```

而后来在重构中（参看[第三讲](http://https://time.geekbang.org/column/intro/100109401?tab=catalog)），我们抽取了OptionParser接口，并将上面的测试改写成了一个范围更小的测试：

```
//OptionParsersTest.BooleanOptionParser

@Test
public void should_set_value_to_true_if_option_present() {
  assertTrue(OptionParsers.bool().parse(asList("-l"), option("l")));
}
```

这两个测试看起来没有什么不同，测试的功能也是一致的功能。但如果严格区分的话，第一个测试是**所谓的**集成测试（Integration Test）或功能测试（Functional Test），而第二个测试，则是我们**常规意义上的单元测试**（Unit Test），也就是对于单一单元的测试。

![](https://static001.geekbang.org/resource/image/25/f2/2513f690c174d3ea87a353119a812df2.jpg?wh=2284x1201)

如上图所示，第一个测试的测试范围包含了Args和OptionParser，可以看作是“集成测试”或“功能测试”。第二个测试的测试范围仅仅覆盖OptionParser，才会被看作是“单元测试”。

正如我们前面提到的，这个OptionParser接口并不是一开始就存在，而是**通过重构获得的**。在重构的过程中，我们从Args中分离了部分代码，从而使得ArgsTest的测试范围不再聚焦于某一个单元，而是覆盖了更多的单元。

于是ArgsTest就成了“集成测试”。更有意思的是，在重构的过程中，虽然这个测试没有任何变动，但是到重构结束的时候，它就从“单元测试”变成了“集成测试”。

## TDD中的单元测试

既然我们没有改变测试代码，而仅仅通过重构就改变了测试的种类，那么我们区分不同种类的测试还有什么意义呢？为什么TDD社区又特别爱强调要编写“单元测试”呢？

在TDD的语境下，“单元测试”指的是**能提供快速反馈的低成本的研发测试（Developer Test）**。TDD社区希望通过强调“单元测试”，来强调这些特点。但是“单元测试”这个词，并不是由TDD社区发明的，而是软件行业中由来已久的一个词汇。在不做任何强调的情况下，它会指**针对不涉及进程外组件的单一软件单元的测试。**

为了让测试能够聚焦到单一的单元，就需要拆分单元间的依赖，那么最终会得到**一组彼此间没有直接耦合关系的小粒度对象**。而如果强制ArgsTest也遵守“单元测试”风格，那我们大概会得到这样的结果：

或许有人会说，这不正是好的面向对象设计吗？这不正是彻底的解耦吗？这种**将所有直接耦合都视为坏味道**的设计取向，会将**功能需求的上下文**打散到一组细碎的对象群落中，增加理解的难度。最终滑向**过度设计**（Over Design）的深渊。

坏味道通常源自过高**认知负载**（Cognitive Load）或不易修改，俗称“看不懂改不动”。比如，坏味道过长的方法（Long Method）不是以绝对代码长度来衡量的，而是以“是否超出认知负载或难以改变其中的行为”来衡量的。而将功能上下文切得过于细碎，也会增加认知负载。**因而不能单纯地认为，这种风格就一定是好的设计**。

而对于进程外组件，正如我们在上节课讲到的，需要将连接真实系统的状态验证转变为行为验证，才能消除对于进程外组件的依赖。由此带来的问题我们已经详细讲解过了：**可能会丧失测试的有效性，并阻碍重构**。

不一定能得到好的设计，可能编写无用的测试，以及可能会阻碍重构而不是像宣称地那样辅助重构，这三点正是很多人对TDD的批评（或者说是疑惑）。比如 *Ruby on Rails* 的作者David Heinemeier Hansson（DHH）就曾极力抨击TDD，并写下长文 *TDD is dead, long live testing* （2014年），痛斥单元测试无益于软件开发。

然而事实真相是，在测试驱动开发中，**从来没有强调必须是“单元测试”**。反而在大多数情况下，都是**针对不同单元粒度的功能测试**。并通过这一系列不同单元粒度的功能测试，驱动软件的开发（正如你在第1-4讲中看到的那样）。

在DHH与Martin Fowler、Kent Beck关于TDD的圆桌会议中，Kent Beck也反复强调，他几乎从不写“单元测试”，而主要是通过构造恰当粒度的黑盒功能测试驱动开发。之后Martin Folwer也再次[写文章谈论单元测试](https://martinfowler.com/bliki/UnitTest.html)，并在其中阐述了TDD社区所谓的单元测试到底是什么。也就是我们前面说的，**能提供快速反馈的低成本的研发测试**。Martin Fowler还建议将TDD中的测试叫作极限单元测试（Xunit Testing），以区别于行业中的叫法。

显然，“单元测试”是一个极具误导性的提法，甚至是TDD不能得到广泛传播的罪魁之一（也是几次TDD大论战的焦点）。这也是为什么从2009年起，我就不再使用“单元测试”来指代TDD中的测试了。转而使用“**单元级别功能测试**（Unit Level Functional Test）**”来指代TDD中需要的那种测试**。

“单元级别功能测试”这个名字同时具有“单元”和“功能”。通过这个名字，我想要强调这样几点：

- TDD中的测试是由不同粒度的功能测试构成的；
- 每一个测试都兼具功能验证和错误定位的功效；
- 要从发现问题和定位问题的角度，去思考测试的效用与成本；
- 单元粒度要以独立的功能上下文或变化点为粒度。

无论是“极限单元测试”还是“单元级别功能测试”，从今天起，**请停止使用“单元测试**”**这样源自测试领域的名字。**毕竟TDD中的测试，并不是一种关于测试的技术，而是通过分解功能以驱动软件开发的技术。

## 小结

今天我们讨论了TDD中的测试到底是什么。它不是行业中所谓的“单元测试”，而是指能提供快速反馈的低成本的研发测试，也是针对不同粒度单元的功能测试。我们要从发现问题和定位问题的角度出发，去理解和思考每一个测试的功效。

在理解了TDD中测试的性质之后，我们就可以开始讲解这样的测试到底驱动了软件哪些部分的开发，以及它到底是怎么驱动的。

## 思考题

请结合课程内容，反驳David Heinemeier Hansson（DHH）的“TDD已死”。

**编辑来信**：

> TDD是一项技能，唯有动手实操、反复练习，才能有所小成。为了帮助你更快地进步，徐昊老师特发起了**“TDD专栏首发·代码评点”**活动。  
> 　  
> 在第一个实战项目结束后，我们会根据你提交的[学习反馈](https://jinshuju.net/f/TvdN15)，手动选出其中几位进行代码评点与解疑答惑。而评点的详细内容我们也将制成加餐，展示在专栏里，供其他同学学习与参考。  
> 　  
> 划重点！如果学完第1-10讲再写反馈，将会大大提高你入选的机会！另，此次收集时间截至4月3日零点。所以非常希望你能跟上我们的更新进度，多动手实操，并记录学习体会。  
> 　  
> 最后，希望我们都能好好学习，更上层楼！
<div><strong>精选留言（15）</strong></div><ul>
<li><span>邓志国</span> 👍（17） 💬（1）<p>TDD 已死的作者，认为TDD的T就是单元测试。所以认为TDD会生成一堆中间的小组件，所以他觉得这种方式不可持续。从这点来看他可能是对的。而现在我们说的TDD实际上是更大粒度的测试。比如在一个业务系统中，可能是对隔离了网络、DB后的业务逻辑整块进行测试，而不是对里面的每个类进行测试。我现在明白了为什么有人会问一个Entity是否需要测试。当然不，对Entity类的调用，在你对业务的测试中自然就会覆盖了。</p>2022-03-23</li><br/><li><span>枫中的刀剑</span> 👍（10） 💬（2）<p>我就被误导了。之前总以为一定要按单元测试，设计成严格的解耦，带来的问题就是过多的使用mock技术，导致后来阅读理解测试成本越来越高。现在看完这篇文章很多疑惑一下子就解开了。</p>2022-03-25</li><br/><li><span>aoe</span> 👍（6） 💬（1）<p>05 06 07 课笔记 http:&#47;&#47;wyyl1.com&#47;post&#47;19&#47;05

状态验证：一波操作后验证返回结果是否和预期一样
行为验证：验证一波操作是否严格按预期的顺序执行，不管结果；对 TDD 用处不大，因为大多数情况下会丧失测试的有效性

❗️恍然大悟
在测试驱动开发中，从来没有强调必须是“单元测试”。反而在大多数情况下，都是针对不同单元粒度的功能测试。并通过这一系列不同单元粒度的功能测试，驱动软件的开发。

⭐️ 两位超级大佬说的
Kent Beck：通过构造恰当粒度的黑盒功能测试驱动开发
Martin Folwer：DD 社区所谓的单元测试到底是“能提供快速反馈的低成本的研发测试”
Martin Fowler：建议将 TDD 中的测试叫作极限单元测试（Xunit Testing），以区别于行业中的叫法



</p>2022-03-27</li><br/><li><span>humor</span> 👍（3） 💬（2）<p>老师，请问什么叫超过认知负载呢。比如同一段代码逻辑，我一开始可能不太熟悉，觉得它又臭又长看不太懂，但是我看了几遍熟悉了之后，就会觉得这段代码逻辑又比较容易理解了。那这段代码逻辑是超出认知负载还是未超出认知负载呢</p>2022-04-16</li><br/><li><span>Gojustforfun</span> 👍（1） 💬（1）<p>我把Test定义为:不同工作单元的功能测试。其中工作单元是指实现某项&#47;些功能，完成某项&#47;些工作的代码集合（类，包，组件等）。</p>2022-03-23</li><br/><li><span>davix</span> 👍（0） 💬（4）<p>如果TDD是功能測試，而我覺得絕大多數功能是單個單元完不成的，那麼TDD產生的UT數就不會多。而測試金字塔理論最底層佔大多數的是UT，還成立嗎？跟TDD是不是矛盾？</p>2022-04-04</li><br/><li><span>邓志国</span> 👍（0） 💬（2）<p>之前看《修改代码的艺术》里面的单元测试，就是指一个类的测试。这种实际上是在测试实现。如果一堆类都有了一个测试，会让我们测试代码和实现绑定死了，从而阻止重构。这点上我觉得TDD的测试更是一种对行为的测试而不是对实现。</p>2022-03-22</li><br/><li><span>程序袁帅</span> 👍（9） 💬（0）<p>老马《单元测试》的中文版：https:&#47;&#47;www.yuque.com&#47;yuanshenjian&#47;agile&#47;unit-test

篇幅很小，作为下午茶吧~</p>2022-04-05</li><br/><li><span>keys头</span> 👍（3） 💬（2）<p>个人理解TDD其实就是一种结果导向的做事方式，或者叫“以终为始”，再配上8x的任务分解法，把大结果分解成小结果，然后稳步得到每一个小结果后，最终目标也就达成了。借用OKR中的概念的话，过程就变成了：确定 Object (目标)，分解 Key Result (关键结果)，获得关键结果，完成目标。所以，我更愿意把“TDD+任务分解法”叫做 
 OKRDD（目标分解+关键结果驱动开发）。😝</p>2022-03-24</li><br/><li><span>枫中的刀剑</span> 👍（2） 💬（0）<p>正如文中所说”毕竟 TDD 中的测试，并不是一种关于测试的技术，而是通过分解功能以驱动软件开发的技术。“。这句才是TDD关注点的核心，而大多数人在谈论TDD的时候都落在单元测试的讨论上去了。 这导致很多还没有接触过TDD的人，都以为重点是单元测试。</p>2022-03-25</li><br/><li><span>俊伟</span> 👍（1） 💬（0）<p>跟我之前想的一样，盲目的用所谓单元测试就会造成大量mock使用。tdd中的test和测试人员眼中的test完全不是一个东西。</p>2022-04-06</li><br/><li><span>范飞扬</span> 👍（0） 💬（1）<p>毕竟 TDD 中的测试，并不是一种关于测试的技术，而是通过分解功能以驱动软件开发的技术。

应该改成

毕竟 TDD 并不是一种关于测试的技术，而是通过分解功能以驱动软件开发的技术。</p>2024-02-18</li><br/><li><span>文经</span> 👍（0） 💬（0）<p>&quot;为了让测试能够聚焦到单一的单元，就需要拆分单元间的依赖，那么最终会得到一组彼此间没有直接耦合关系的小粒度对象。&quot;
拆分成一组耦合的对象，在这里关键不是有没有直接耦合，而是这种耦合关系会不会变化？
像代码里的PARSERS，不需要有变化的场景，也就没有当做参数来传递的必要，可以直接依赖。</p>2023-01-17</li><br/><li><span>zenk</span> 👍（0） 💬（2）<p>老师，为啥叫『独立的功能上下文或变化点』

比较难理解这两个词</p>2022-05-07</li><br/><li><span>davix</span> 👍（0） 💬（3）<p>這麼說TDD不是變成BDD了？</p>2022-04-04</li><br/>
</ul>