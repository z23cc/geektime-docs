在软件开发过程中，我们经常会使用各种编程框架。如果你使用的是Java，那么你会比较熟悉Spring、MyBatis等。事实上，Tomcat、Jetty这类Web容器也可以归类为框架。框架的一个特点是，当开发者使用框架开发一个应用程序时，无需在程序中调用框架的代码，就可以使用框架的功能特性。比如程序不需要调用Spring的代码，就可以使用Spring的依赖注入，MVC这些特性，开发出低耦合、高内聚的应用代码。我们的程序更不需要调用Tomcat的代码，就可以监听HTTP协议端口，处理HTTP请求。

这些框架我们每天都在使用，已经司空见惯，所以觉得这种实现理所当然，但是我们停下好好想一想，难道不觉得这很神奇吗？我们自己也写代码，能够做到让其他工程师不调用我们的代码就可以使用我们的代码的功能特性吗？就我观察，大多数开发者是做不到的。那么Spring、Tomcat这些框架是如何做到的呢？

## 依赖倒置原则

我们看下Spring、Tomcat这些框架设计的核心关键点，也就是面向对象的基本设计原则之一：依赖倒置原则。

依赖倒置原则是这样的：

- 高层模块不应该依赖低层模块，二者都应该依赖抽象。
- 抽象不应该依赖具体实现，具体实现应该依赖抽象。

软件分层设计已经是软件开发者的共识。事实上，最早引入软件分层设计，正是为了建立清晰的软件分层关系，便于高层模块依赖低层模块。一般的应用程序中，策略层会依赖方法层，业务逻辑层会依赖数据存储层。这正是我们日常软件设计开发的常规方式。

那么这种高层模块依赖低层模块的分层依赖方式有什么缺点呢？

一是维护困难，高层模块通常是业务逻辑和策略模型，是一个软件的核心所在。正是高层模块使一个软件区别于其他软件，而低层模块则更多的是技术细节。如果高层模块依赖低层模块，那么就是业务逻辑依赖技术细节，技术细节的改变将影响到业务逻辑，使业务逻辑也不得不做出改变。因为技术细节的改变而影响业务代码的改变，这是不合理的。

二是复用困难，通常越是高层模块，复用的价值越高。但如果高层模块依赖低层模块，那么对高层模块的依赖将会导致对底层模块的连带依赖，使复用变得困难。

事实上，在我们软件开发中，很多地方都使用了依赖倒置原则。我们在Java开发中访问数据库，代码并不直接依赖数据库的驱动，而是依赖JDBC。各种数据库的驱动都实现了JDBC，当应用程序需要更换数据库的时候，不需要修改任何代码。这正是因为应用代码，高层模块，不依赖数据库驱动，而是依赖抽象JDBC，而数据库驱动，作为低层模块，也依赖JDBC。

同样的，Java开发的Web应用也不需要依赖Tomcat这样的Web容器，只需要依赖J2EE规范，Web应用实现J2EE规范的Servlet接口，然后把应用程序打包通过Web容器启动就可以处理HTTP请求了。这个Web容器可以是Tomcat，也可以是Jetty，任何实现了J2EE规范的Web容器都可以。同样，高层模块不依赖低层模块，大家都依赖J2EE规范。

其他我们熟悉的MVC框架，ORM框架，也都遵循依赖倒置原则。

## 依赖倒置的关键是接口所有权的倒置

下面，我们进一步了解下依赖倒置原则的设计原理，看看如何在我们的程序设计开发中也能利用依赖倒置原则，开发出更少依赖、更低耦合、更可复用的代码。

这是我们习惯上的层次依赖示例，策略层依赖方法层，方法层依赖工具层。

![](https://static001.geekbang.org/resource/image/46/df/4642c03ba5b5f36baac550326e0943df.png?wh=471%2A181)

这样分层依赖的一个潜在问题是，策略层对方法层和工具层是传递依赖的，下面两层的任何改动都会导致策略层的改动，这种传递依赖导致的级联改动可能会导致软件维护过程非常糟糕。

解决办法是利用依赖倒置的设计原则，每个高层模块都为它所需要的服务声明一个抽象接口，而低层模块则实现这些抽象接口，高层模块通过抽象接口使用低层模块。

![](https://static001.geekbang.org/resource/image/80/7e/80d012cfab510eb1d4e7a57ab2f6277e.png?wh=920%2A688)

这样，高层模块就不需要直接依赖低层模块，而变成了低层模块依赖高层模块定义的抽象接口，从而实现了依赖倒置，解决了策略层、方法层、工具层的传递依赖问题。

我们日常的开发通常也要依赖抽象接口，而不是依赖具体实现。比如Web开发中，Service层依赖DAO层，并不是直接依赖DAO的具体实现，而是依赖DAO提供的抽象接口。那么这种依赖是否是依赖倒置呢？其实并不是，依赖倒置原则中，除了具体实现要依赖抽象，最重要的是，抽象是属于谁的抽象。

通常的编程习惯中，低层模块拥有自己的接口，高层模块依赖低层模块提供的接口，比如方法层有自己的接口，策略层依赖方法层的接口；DAO层定义自己的接口，Service层依赖DAO层定义的接口。

但是按照依赖倒置原则，接口的所有权是被倒置的，也就是说，接口被高层模块定义，高层模块拥有接口，低层模块实现接口。不是高层模块依赖底层模块的接口，而是低层模块依赖高层模块的接口，从而实现依赖关系的倒置。

在上面的依赖层次中，每一层的接口都被高层模块定义，由低层模块实现，高层模块完全不依赖低层模块，即使是低层模块的接口。这样，低层模块的改动不会影响高层模块，高层模块的复用也不会依赖低层模块。对于Service和DAO这个例子来说，就是Service定义接口，DAO实现接口，这样才符合依赖倒置原则。

## 使用依赖倒置实现高层模块复用

依赖倒置原则适用于一个类向另一个类发送消息的场景。我们再看一个例子。

Button按钮控制Lamp灯泡，按钮按下的时候，灯泡点亮或者关闭。按照常规的设计思路，我们可能会设计出如下的类图关系，Button类直接依赖Lamp类。

![](https://static001.geekbang.org/resource/image/bd/2a/bd66b7500645cff489244fb6b1a85a2a.png?wh=937%2A213)

这样设计的问题在于，Button依赖Lamp，那么对Lamp的任何改动，都可能会使Button受到牵连，做出联动的改变。同时，我们也无法重用Button类，比如，我们期望通过Button控制一个电机的启动或者停止，这种设计显然难以重用Button，因为我们的Button还依赖着Lamp呢。

解决之道就是将这个设计中的依赖于实现，重构为依赖于抽象。这里的抽象就是：打开关闭目标对象。至于具体的实现细节，比如开关指令如何产生，目标对象是什么，都不重要。这是重构后的设计。

![](https://static001.geekbang.org/resource/image/48/06/48774cef9ca8ee0a44797c4482820b06.png?wh=887%2A472)

由Button定义一个抽象接口ButtonServer；在ButtonServer中描述抽象：打开、关闭目标对象。由具体的目标对象，比如Lamp实现这个接口，从而完成Button控制Lamp这一功能需求。

通过这样一种依赖倒置，Button不再依赖Lamp，而是依赖抽象ButtonServer，而Lamp也依赖ButtonServer，高层模块和低层模块都依赖抽象。Lamp的改动不会再影响Button，而Button 可以复用控制其他目标对象，比如电机，或者任何由按钮控制的设备，只要这些设备实现ButtonServer接口就可以了。

这里再强调一次，抽象接口ButtonServer的所有权是倒置的，它不属于底层模块Lamp，而是属于高层模块Button。我们从命名上也能看的出来，这正是依赖倒置原则的精髓所在。

这也正好回答了开头提出的问题：如何使其他工程师不调用我们的代码，就能使用我们代码的功能特性？如果我们是Button的开发者，那么只要其他工程师的代码实现了我们定义的ButtonServer接口，Button就可以调用他们开发的Lamp或者其他任何由按钮控制的设备，使设备代码拥有了按钮功能。设备的代码开发者不需要调用Button的代码，就拥有了Button的功能，而我们，也不需要关心Button会在什么样的设备代码中使用，所有实现ButtonServer的设备都可以使用Button功能。

所以依赖倒置原则也被称为好莱坞原则：Don’t call me，I will call you. 即不要来调用我，我会调用你。Tomcat、Spring都是基于这一原则设计出来的，应用程序不需要调用Tomcat或者Spring这样的框架，而是框架调用应用程序。而实现这一特性的前提就是应用程序必须实现框架的接口规范，比如实现Servlet接口。

## 小结

依赖倒置原则通俗说就是，高层模块不依赖低层模块，而是都依赖抽象接口，这个抽象接口通常是由高层模块定义，低层模块实现。

遵循依赖倒置原则有这样几个编码守则：

1. 应用代码中多使用抽象接口，尽量避免使用那些多变的具体实现类。
2. 不要继承具体类，如果一个类在设计之初不是抽象类，那么尽量不要去继承它。对具体类的继承是一种强依赖关系，维护的时候难以改变。
3. 不要重写（override）包含具体实现的函数。

依赖倒置原则最典型的使用场景就是框架的设计。框架提供框架核心功能，比如HTTP处理，MVC等，并提供一组接口规范，应用程序只需要遵循接口规范编程，就可以被框架调用。程序使用框架的功能，但是不调用框架的代码，而是实现框架的接口，被框架调用，从而框架有更高的可复用性，被应用于各种软件开发中。

我们的代码开发也可以按照依赖倒置原则，参考框架的设计理念，开发出灵活、低耦合、可复用的软件代码。

软件开发有时候像变魔术一样，常常表现出违反常识的特性，让人目眩神晕，而这正是软件编程这门艺术的魅力所在，感受到这种魅力，在自己的软件设计开发中体现出这种魅力，你就迈进了软件高手的大门。

## 思考题

除了文中的例子，还有哪些软件设计遵循了依赖倒置原则？这些软件中，底层模块和高层模块共同依赖的抽象是什么？

欢迎你在评论区写下你的思考，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。
<div><strong>精选留言（15）</strong></div><ul>
<li><span>山猫</span> 👍（69） 💬（10）<p>依赖倒置这个东西懂得人是真懂，不懂的人是一点不懂。当初为了搞懂依赖倒置原则花了相当长时间去阅读大量的文章和书籍，看了很多代码事例，后来又看了面对对象设计原则才算基本理解。

之前给公司开发培训，他们仍旧听的一脸懵逼，觉得这是个噱头。直到我跟他们说：老板就是找个写代码的人，别把自己看的那么重。你们每天写那么多bug，别怪老板说要换人。他们才理解！</p>2019-12-18</li><br/><li><span>唐二毛</span> 👍（17） 💬（3）<p>疑问: 按照我的理解，上层定义接口，对应到项目(传统三层架构)，就是controller 层定义 service 层的接口，service层定义 dao层的接口，是这样吗？ DI的目的是减少功能变化时，对代码的修改，可是我发现一旦这么做的时候，不但不能减少，反而会增加，因为功能的变化一般都是最上层的变化，比如: 参数的增加，减少，参数中字段的增加，减少，修改，这样的每一个变化都会影响到每一层的接口，所以在每一次功能变化的时候，都需要将整个调用链路的代码修改。 如果每层之间都加了防腐层，那每次变化都陷入到繁琐的改字段，测试字段之中。所有的unit test也要跟着变。这样真就是完完全全的牵一发而动全身!  有时我甚至觉得，把一个功能缩在一个类中，反而会更简单! 希望老师务必解答我的疑问，这个问题困扰我很久了!</p>2019-12-19</li><br/><li><span>奕</span> 👍（6） 💬（1）<p>高层模块和底层模块是依据什么划分的？</p>2019-12-18</li><br/><li><span>gx</span> 👍（4） 💬（1）<p>人操作车，人是高层车是低层，当车变化人就要跟着变化，人是依赖车的，这时候高层依赖低层。 让人定义用车的接口，人操作接口，车必须符合接口，这时候车是依赖人定义的接口，不管车怎么变都必须符合接口，变成了低层依赖高层。形成了依赖倒置。也就是调用者(人)定义接口，而不是实现者(车)定义接口。其实就是面向接口编程，解耦。依赖倒置后好处就是，需要调整代码的地方变少了。变动前所有接口的位置都要变成车，倒置后，所有接口的地方都不用变动。代码变动少了。</p>2024-05-01</li><br/><li><span>池渊</span> 👍（4） 💬（1）<p>怎么觉得依赖倒置和面向接口编程说的是同一个东西，是哪里理解有误吗？老师帮解答下</p>2020-02-05</li><br/><li><span>QQ怪</span> 👍（1） 💬（2）<p>懂了懂了，看了3遍，听了3遍，基本理解，但是也不能太刻板的认为一定得是高层定义接口吧，只要都依赖抽象感觉就行了，不需要太计较这个抽象层在哪吧</p>2019-12-30</li><br/><li><span>飞翔</span> 👍（0） 💬（1）<p>老师 想问一下依赖倒置 和普通接口 底层模块自己定义接口 什么时候用依赖倒置 什么时候用普通接口呀</p>2023-03-20</li><br/><li><span>惘 闻</span> 👍（0） 💬（1）<p>spring的依赖注入也是控制反转.从应用程序new Bean()变为给这段应用程序注入一个Bean,将Bean的获取由程序new变为框架注入.原本是应用程序控制具体的Bean,现在变为了Bean控制应用程序???? 头大 想不明白啊. 但是倒是符合程序不new Bean,Bean去自动注入程序.也就是好莱坞原则.</p>2021-02-18</li><br/><li><span>席席</span> 👍（0） 💬（2）<p>李老师，既然依赖倒置设计原则是高层模块抽象接口，低层模块实现接口，那么为什么web项目中还要在service层抽象接口，然后再用接口调用低层Dao呢，是否多此一举？</p>2020-06-30</li><br/><li><span>leslykay</span> 👍（0） 💬（1）<p>Lamp实现ButtonServer的那个UML图，是不是要改成虚线加空心三角形？</p>2020-02-09</li><br/><li><span>虢國技醬</span> 👍（0） 💬（1）<p>看了这几篇我感觉：接口这种类型非常重要；接口定义的好坏代表了我们是否对一类操作“抽象”的恰当。
</p>2020-01-21</li><br/><li><span>靠人品去赢</span> 👍（0） 💬（1）<p>其实看很多框架的一些类的UML图，基本都是顶层是一个抽象的父类，然好一大堆接口引用。现在知道是依赖倒置思想作指导，但我有一个问题，想我们即使去使用抽象父类，来复用代码，虽然不会产生实例，但是怎么设计这个父类呢？有什么指导思想？比如我设计一个鸟类，比如会飞这个方法，有的特例企鹅就是不会飞，还有筑巢也是这样，怎么设计最好呢，还是压根不用父类？</p>2019-12-19</li><br/><li><span>Paul Shan</span> 👍（30） 💬（0）<p>电力系统用了依赖倒置原则，电力系统规定了用电的业务逻辑和插座接口，家用电器只要符合插座接口即可使用。</p>2019-12-23</li><br/><li><span>台风骆骆</span> 👍（12） 💬（0）<p>我觉得linux的vfs也是这种依赖倒置的，vfs定义一组通用的函数，如read,write,open,close，具体的文件系统实现这些接口，系统调用的时候去调用file结构中的f_op（对应具体的文件系统操作）。</p>2019-12-18</li><br/><li><span>Knuth</span> 👍（4） 💬（0）<p>看了以后，最大的感觉是为了开闭原则而开闭原则，提出了一系列的设计模式，感觉在讲述的过程中缺少一些推理和比较，直接就给结论，觉得很生硬</p>2020-01-08</li><br/>
</ul>