你好，我是郝林，今天我们继续分享go语句执行规则的内容。

在上一篇文章中，我们讲到了goroutine在操作系统的并发编程体系，以及在Go语言并发编程模型中的地位和作用等一系列内容，今天我们继续来聊一聊这个话题。

## 知识扩展

**问题1：怎样才能让主goroutine等待其他goroutine？**

我刚才说过，一旦主goroutine中的代码执行完毕，当前的Go程序就会结束运行，无论其他的goroutine是否已经在运行了。那么，怎样才能做到等其他的goroutine运行完毕之后，再让主goroutine结束运行呢？

其实有很多办法可以做到这一点。其中，最简单粗暴的办法就是让主goroutine“小睡”一会儿。

```
for i := 0; i < 10; i++ {
	go func() {
		fmt.Println(i)
	}()
}
time.Sleep(time.Millisecond * 500)
```

在`for`语句的后边，我调用了`time`包的`Sleep`函数，并把`time.Millisecond * 500`的结果作为参数值传给了它。`time.Sleep`函数的功能就是让当前的goroutine（在这里就是主goroutine）暂停运行一段时间，直到到达指定的恢复运行时间。

我们可以把一个相对的时间传给该函数，就像我在这里传入的“500毫秒”那样。`time.Sleep`函数会在被调用时用当前的绝对时间，再加上相对时间计算出在未来的恢复运行时间。显然，一旦到达恢复运行时间，当前的goroutine就会从“睡眠”中醒来，并开始继续执行后边的代码。

这个办法是可行的，只要“睡眠”的时间不要太短就好。不过，问题恰恰就在这里，我们让主goroutine“睡眠”多长时间才是合适的呢？如果“睡眠”太短，则很可能不足以让其他的goroutine运行完毕，而若“睡眠”太长则纯属浪费时间，这个时间就太难把握了。

你可能会想到，既然不容易预估时间，那我们就让其他的goroutine在运行完毕的时候告诉我们好了。这个思路很好，但怎么做呢？

你是否想到了通道呢？我们先创建一个通道，它的长度应该与我们手动启用的goroutine的数量一致。在每个手动启用的goroutine即将运行完毕的时候，我们都要向该通道发送一个值。

注意，这些发送表达式应该被放在它们的`go`函数体的最后面。对应的，我们还需要在`main`函数的最后从通道接收元素值，接收的次数也应该与手动启用的goroutine的数量保持一致。关于这些你可以到demo39.go文件中，去查看具体的写法。

其中有一个细节你需要注意。我在声明通道`sign`的时候是以`chan struct{}`作为其类型的。其中的类型字面量`struct{}`有些类似于空接口类型`interface{}`，它代表了既不包含任何字段也不拥有任何方法的空结构体类型。

注意，`struct{}`类型值的表示法只有一个，即：`struct{}{}`。并且，它占用的内存空间是`0`字节。确切地说，这个值在整个Go程序中永远都只会存在一份。虽然我们可以无数次地使用这个值字面量，但是用到的却都是同一个值。

当我们仅仅把通道当作传递某种简单信号的介质的时候，用`struct{}`作为其元素类型是再好不过的了。顺便说一句，我在讲“结构体及其方法的使用法门”的时候留过一道与此相关的思考题，你可以返回去看一看。

再说回当下的问题，有没有比使用通道更好的方法？如果你知道标准库中的代码包`sync`的话，那么可能会想到`sync.WaitGroup`类型。没错，这是一个更好的答案。不过具体的使用方式我在后边讲`sync`包的时候再说。

**问题2：怎样让我们启用的多个goroutine按照既定的顺序运行？**

在很多时候，当我沿着上面的主问题以及第一个扩展问题一路问下来的时候，应聘者往往会被这第二个扩展问题难住。

所以基于上一篇主问题中的代码，怎样做到让从`0`到`9`这几个整数按照自然数的顺序打印出来？你可能会说，我不用goroutine不就可以了嘛。没错，这样是可以，但是如果我不考虑这样做呢。你应该怎么解决这个问题？

当然了，众多应聘者回答的其他答案也是五花八门的，有的可行，有的不可行，还有的把原来的代码改得面目全非。我下面就来说说我的思路，以及心目中的答案吧。这个答案并不一定是最佳的，也许你在看完之后还可以想到更优的答案。

首先，我们需要稍微改造一下`for`语句中的那个`go`函数，要让它接受一个`int`类型的参数，并在调用它的时候把变量`i`的值传进去。为了不改动这个`go`函数中的其他代码，我们可以把它的这个参数也命名为`i`。

```
for i := 0; i < 10; i++ {
	go func(i int) {
		fmt.Println(i)
	}(i)
}
```

只有这样，Go语言才能保证每个goroutine都可以拿到一个唯一的整数。其原因与`go`函数的执行时机有关。

我在前面已经讲过了。在`go`语句被执行时，我们传给`go`函数的参数`i`会先被求值，如此就得到了当次迭代的序号。之后，无论`go`函数会在什么时候执行，这个参数值都不会变。也就是说，`go`函数中调用的`fmt.Println`函数打印的一定会是那个当次迭代的序号。

然后，我们在着手改造`for`语句中的`go`函数。

```
for i := uint32(0); i < 10; i++ {
	go func(i uint32) {
		fn := func() {
			fmt.Println(i)
		}
		trigger(i, fn)
	}(i)
}
```

我在`go`函数中先声明了一个匿名的函数，并把它赋给了变量`fn`。这个匿名函数做的事情很简单，只是调用`fmt.Println`函数以打印`go`函数的参数`i`的值。

在这之后，我调用了一个名叫`trigger`的函数，并把`go`函数的参数`i`和刚刚声明的变量`fn`作为参数传给了它。注意，`for`语句声明的局部变量`i`和`go`函数的参数`i`的类型都变了，都由`int`变为了`uint32`。至于为什么，我一会儿再说。

再来说`trigger`函数。该函数接受两个参数，一个是`uint32`类型的参数`i`, 另一个是`func()`类型的参数`fn`。你应该记得，`func()`代表的是既无参数声明也无结果声明的函数类型。

```
trigger := func(i uint32, fn func()) {
	for {
		if n := atomic.LoadUint32(&count); n == i {
			fn()
			atomic.AddUint32(&count, 1)
			break
		}
		time.Sleep(time.Nanosecond)
	}
}
```

`trigger`函数会不断地获取一个名叫`count`的变量的值，并判断该值是否与参数`i`的值相同。如果相同，那么就立即调用`fn`代表的函数，然后把`count`变量的值加`1`，最后显式地退出当前的循环。否则，我们就先让当前的goroutine“睡眠”一个纳秒再进入下一个迭代。

注意，我操作变量`count`的时候使用的都是原子操作。这是由于`trigger`函数会被多个goroutine并发地调用，所以它用到的非本地变量`count`，就被多个用户级线程共用了。因此，对它的操作就产生了竞态条件（race condition），破坏了程序的并发安全性。

所以，我们总是应该对这样的操作加以保护，在`sync/atomic`包中声明了很多用于原子操作的函数。

另外，由于我选用的原子操作函数对被操作的数值的类型有约束，所以我才对`count`以及相关的变量和参数的类型进行了统一的变更（由`int`变为了`uint32`）。

纵观`count`变量、`trigger`函数以及改造后的`for`语句和`go`函数，我要做的是，让`count`变量成为一个信号，它的值总是下一个可以调用打印函数的`go`函数的序号。

这个序号其实就是启用goroutine时，那个当次迭代的序号。也正因为如此，`go`函数实际的执行顺序才会与`go`语句的执行顺序完全一致。此外，这里的`trigger`函数实现了一种自旋（spinning）。除非发现条件已满足，否则它会不断地进行检查。

最后要说的是，因为我依然想让主goroutine最后一个运行完毕，所以还需要加一行代码。不过既然有了`trigger`函数，我就没有再使用通道。

```
trigger(10, func(){})
```

调用`trigger`函数完全可以达到相同的效果。由于当所有我手动启用的goroutine都运行完毕之后，`count`的值一定会是`10`，所以我就把`10`作为了第一个参数值。又由于我并不想打印这个`10`，所以我把一个什么都不做的函数作为了第二个参数值。

总之，通过上述的改造，我使得异步发起的`go`函数得到了同步地（或者说按照既定顺序地）执行，你也可以动手自己试一试，感受一下。

**总结**

在本篇文章中，我们接着上一篇文章的主问题，讨论了当我们想让运行结果更加可控的时候，应该怎样去做。

主goroutine的运行若过早结束，那么我们的并发程序的功能就很可能无法全部完成。所以我们往往需要通过一些手段去进行干涉，比如调用`time.Sleep`函数或者使用通道。我们在后面的文章中还会讨论更高级的手段。

另外，`go`函数的实际执行顺序往往与其所属的`go`语句的执行顺序（或者说goroutine的启用顺序）不同，而且默认情况下的执行顺序是不可预知的。那怎样才能让这两个顺序一致呢？其实复杂的实现方式有不少，但是可能会把原来的代码改得面目全非。我在这里提供了一种比较简单、清晰的改造方案，供你参考。

总之，我希望通过上述基础知识以及三个连贯的问题帮你串起一条主线。这应该会让你更快地深入理解goroutine及其背后的并发编程模型，从而更加游刃有余地使用`go`语句。

**思考题**

1.`runtime`包中提供了哪些与模型三要素G、P和M相关的函数？（模型三要素内容在上一篇）

[戳此查看Go语言专栏文章配套详细代码。](https://github.com/hyper0x/Golang_Puzzlers)
<div><strong>精选留言（15）</strong></div><ul>
<li><span>枫林火山</span> 👍（70） 💬（4）<p>老师，关于顺序打印的demo40.go的优化版本，同来碗绿豆汤同学的实现
package main

import &quot;fmt&quot;

func main() {

	var num = 10
	sign := make(chan struct{}, 1)

	for i := 0; i &lt; num; i++ {
		go func(i int) {
			fmt.Println(i)
			sign &lt;- struct{}{}
		}(i)
		&lt;-sign
	}

}
这样写为什么不能保证同步，能不能再详细解释下呢。这个实现和您demo39.go 相比，只是合并了两处for循环，我看好多同学也有这个疑问，向您求解。
demo40.go的实现相当于实现了每个异步线程的一个轮询loop。 上面的实现相当于单步间加了一个barrier。执行1-&gt;等待-&gt;执行2-&gt;等待。 实在没理解为什么不能保证同步</p>2019-04-01</li><br/><li><span>来碗绿豆汤</span> 👍（37） 💬（9）<p>我有一个更简单的实现方式， 如下
func main(){
	ch := make(chan struct{})
	for i:=0; i &lt; 100; i++{
		go func(i int){
			fmt.Println(i)
			ch &lt;- struct{}{}
		}(i)
		&lt;-ch
	}
}
这样，每次循环都包装goroutine 执行结束才进入下一次循环，就可以保证顺序执行了</p>2018-09-19</li><br/><li><span>Geek_3241ef</span> 👍（20） 💬（1）<p>你好，郝老师，请问这里为什么需要sleep呢，我理解的如果不加sleep，其中某个g会一直轮询count的值，当另一个g更改这个值时，那么第一个g就会判断相等才对呀。
但实际上去掉sleep后，程序确实没有按照我理解的逻辑执行，请问这是为什么呢</p>2019-08-26</li><br/><li><span>Askerlve</span> 👍（12） 💬（7）<p>package main

import (
	&quot;fmt&quot;
	&quot;sync&#47;atomic&quot;
)

func main() {
	var count uint32
	trigger := func(i uint32, fn func()) {
		for {
			if n := atomic.LoadUint32(&amp;count); n == i {
				fn()
				atomic.AddUint32(&amp;count, 1)
				break
			}
		}
	}
	for i := uint32(0); i &lt; 10; i++ {
		go func(i uint32) {
			fn := func() {
				fmt.Println(i)
			}
			trigger(i, fn)
		}(i)
	}
	trigger(10, func() {})
}

测试了下，这个函数的输出不受控，并且好像永远也不会结束，有人能帮忙解释下吗，go小白~😀</p>2018-09-19</li><br/><li><span>老茂</span> 👍（10） 💬（1）<p>不加sleep程序不能正常结束的情况貌似跟cpu核数有关，我是4核cpu，打印0到2每次都可以正常执行；0到3以上就会有卡主的情况，卡主时cpu达到100%，load会超过4。猜测是不是此时所有cpu都在处理count==0的for循环，没有空闲的cpu执行atomic.AddUint32(&amp;count, 1)？</p>2018-10-15</li><br/><li><span>新垣结裤</span> 👍（8） 💬（1）<p>func main() {
	num := 10
	chs := [num+1]chan struct{}{}
	for i := 0; i &lt; num+1; i++ {
		chs[i] = make(chan struct{})
	}
	for i := 0; i &lt; num; i++ {
		go func(i int) {
			&lt;- chs[i]
			fmt.Println(i)
			chs[i+1] &lt;- struct{}{}
		}(i)
	}
	chs[0] &lt;- struct{}{}
	&lt;- chs[num]
}
每个goroutine执行完通过channel通知下一个goroutine，在主goroutine里控制第一个goroutine的开始，并接收最后一个goroutine结束的信号</p>2018-09-21</li><br/><li><span>言午木杉</span> 👍（7） 💬（3）<p>这篇加了代码，一下子就容易很多了，老师前面的几篇都太多名词了，需要琢磨去好几遍</p>2020-01-14</li><br/><li><span>Askerlve</span> 👍（7） 💬（1）<p>package main

import (
	&quot;fmt&quot;
	&quot;sync&#47;atomic&quot;
)

func main() {
	var count uint32
	trigger := func(i uint32, fn func()) {
		for {
			if n := atomic.LoadUint32(&amp;count); n == i {
				fn()
				atomic.AddUint32(&amp;count, 1)
				break
			}
		}
	}
	for i := uint32(0); i &lt; 10; i++ {
		go func(i uint32) {
			fn := func() {
				fmt.Println(i)
			}
			trigger(i, fn)
		}(i)
	}
	trigger(10, func() {})
}

这个函数的执行还是不可控诶，并且好像永远也不会结束，是因为我的go版本问题吗？</p>2018-09-19</li><br/><li><span>肖恩</span> 👍（6） 💬（2）<p>第一遍看好多都看不懂，看到后边回过头来看，发现用自旋goroutine实现，真实奇妙；现在想想，除了文章中实现方式，可以用channel同步实现；还可以用sync.WaitGroup实现</p>2019-05-08</li><br/><li><span>嗷大猫的鱼</span> 👍（6） 💬（2）<p>老师，最近从头学习，前面一直没跟着动手，也没自己总结。这几天在整理每章的重点！

https:&#47;&#47;github.com&#47;wenxuwan&#47;go36

刚写完第二章，突然发现自己动手总结和只看差好多。我会继续保持喜欢总结！</p>2018-09-20</li><br/><li><span>sky</span> 👍（4） 💬（1）<p>win64版本：go1.10.2
linux64版本：go1.11

linux下实际运行和预期一样，但为何win下会一直运行不会停止呢，且CPU也已经是100% 表示不解呀</p>2018-09-19</li><br/><li><span>冰激凌的眼泪</span> 👍（4） 💬（1）<p>‘’否则，我们就先让当前的 goroutine“睡眠”一个纳秒再进入下一个迭代。‘’

示例代码里没有这个睡眠代码</p>2018-09-19</li><br/><li><span>传说中的成大大</span> 👍（3） 💬（2）<p>本节内容主要是讲了 goroutine同步那一块 
主要通过通道 信号 应该sync包中也会有同步相关的函数
我又去把16讲那个G队列再想了一遍
实际上可能存在多个G队列 G队列之间属于并发关系
但是G队列当中他们又是队列储存 顺序执行的</p>2020-03-19</li><br/><li><span>SuperP ❤ 飝</span> 👍（3） 💬（1）<p>runtime.GOMAXPROCS  这个应该能控制P的数量</p>2018-10-11</li><br/><li><span>cygnus</span> 👍（3） 💬（1）<p>demo40的执行结果不是幂等的，程序经常无法正常结束退出，只有极少数几次有正确输出。</p>2018-09-19</li><br/>
</ul>