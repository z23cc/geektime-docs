从架构设计上来说，高可扩展性是一个设计的指标，它表示可以通过增加机器的方式来线性提高系统的处理能力，从而承担更高的流量和并发。

你可能会问：“在架构设计之初，为什么不预先考虑好使用多少台机器，支持现有的并发呢？”这个问题我在“[03 | 系统设计目标（一）：如何提升系统性能？](https://time.geekbang.org/column/article/139474)”一课中提到过，答案是峰值的流量不可控。

一般来说，基于成本考虑，在业务平稳期，我们会预留30%～50%的冗余以应对运营活动或者推广可能带来的峰值流量，但是当有一个突发事件发生时，流量可能瞬间提升到2～3倍甚至更高，我们还是以微博为例。

鹿晗和关晓彤互圈公布恋情，大家会在两个人的微博下面，或围观，或互动，微博的流量短时间内增长迅速，微博信息流也短暂出现无法刷出新的消息的情况。

那我们要如何应对突发的流量呢？架构的改造已经来不及了，最快的方式就是堆机器。不过我们需要保证，扩容了三倍的机器之后，相应的我们的系统也能支撑三倍的流量。有的人可能会产生疑问：“这不是显而易见的吗？很简单啊。”真的是这样吗？我们来看看做这件事儿难在哪儿。

## 为什么提升扩展性会很复杂

在上一讲中，我提到可以在单机系统中通过增加处理核心的方式，来增加系统的并行处理能力，但这个方式并不总奏效。因为当并行的任务数较多时，系统会因为争抢资源而达到性能上的拐点，系统处理能力不升反降。

而对于由多台机器组成的集群系统来说也是如此。集群系统中，不同的系统分层上可能存在一些“瓶颈点”，这些瓶颈点制约着系统的横向扩展能力。这句话比较抽象，我举个例子你就明白了。

比方说，你系统的流量是每秒1000次请求，对数据库的请求量也是每秒1000次。如果流量增加10倍，虽然系统可以通过扩容正常服务，数据库却成了瓶颈。再比方说，单机网络带宽是50Mbps，那么如果扩容到30台机器，前端负载均衡的带宽就超过了千兆带宽的限制，也会成为瓶颈点。那么，我们的系统中存在哪些服务会成为制约系统扩展的重要因素呢？

其实，无状态的服务和组件更易于扩展，而像MySQL这种存储服务是有状态的，就比较难以扩展。因为向存储集群中增加或者减少机器时，会涉及大量数据的迁移，而一般传统的关系型数据库都不支持。这就是为什么提升系统扩展性会很复杂的主要原因。

除此之外，从例子中你可以看到，我们需要站在整体架构的角度，而不仅仅是业务服务器的角度来考虑系统的扩展性 。**所以说，数据库、缓存、依赖的第三方、负载均衡、交换机带宽等等**都是系统扩展时需要考虑的因素。我们要知道系统并发到了某一个量级之后，哪一个因素会成为我们的瓶颈点，从而针对性地进行扩展。

针对这些复杂的扩展性问题，我提炼了一些系统设计思路，供你了解。

## 高可扩展性的设计思路

**拆分**是提升系统扩展性最重要的一个思路，它会把庞杂的系统拆分成独立的，有单一职责的模块。相对于大系统来说，考虑一个一个小模块的扩展性当然会简单一些。**将复杂的问题简单化，这就是我们的思路。**

但对于不同类型的模块，我们在拆分上遵循的原则是不一样的。我给你举一个简单的例子，假如你要设计一个社区，那么社区会有几个模块呢？可能有5个模块。

- 用户：负责维护社区用户信息，注册，登陆等；
- 关系：用户之间关注、好友、拉黑等关系的维护；
- 内容：社区发的内容，就像朋友圈或者微博的内容；
- 评论、赞：用户可能会有的两种常规互动操作；
- 搜索：用户的搜索，内容的搜索。

而部署方式按照最简单的三层部署架构，负载均衡负责请求的分发，应用服务器负责业务逻辑的处理，数据库负责数据的存储落地。这时，所有模块的业务代码都混合在一起了，数据也都存储在一个库里。

![](https://static001.geekbang.org/resource/image/58/a6/5803451931917e0806c37c39802410a6.jpg?wh=1142%2A920)

#### 1.存储层的扩展性

无论是存储的数据量，还是并发访问量，不同的业务模块之间的量级相差很大，比如说成熟社区中，关系的数据量是远远大于用户数据量的，但是用户数据的访问量却远比关系数据要大。所以假如存储目前的瓶颈点是容量，那么我们只需要针对关系模块的数据做拆分就好了，而不需要拆分用户模块的数据。**所以存储拆分首先考虑的维度是业务维度。**

拆分之后，这个简单的社区系统就有了用户库、内容库、评论库、点赞库和关系库。这么做还能隔离故障，某一个库“挂了”不会影响到其它的数据库。

![](https://static001.geekbang.org/resource/image/5e/b6/5ee6e1350e2d4d5514a05032b10bd3b6.jpg?wh=1142%2A854)

按照业务拆分，在一定程度上提升了系统的扩展性，但系统运行时间长了之后，单一的业务数据库在容量和并发请求量上仍然会超过单机的限制。**这时，我们就需要针对数据库做第二次拆分。**

这次拆分是按照数据特征做水平的拆分，比如说我们可以给用户库增加两个节点，然后按照某些算法将用户的数据拆分到这三个库里面，具体的算法我会在后面讲述数据库分库分表时和你细说。

水平拆分之后，我们就可以让数据库突破单机的限制了。但这里要注意，我们不能随意地增加节点，因为一旦增加节点就需要手动地迁移数据，成本还是很高的。所以基于长远的考虑，我们最好一次性增加足够的节点以避免频繁的扩容。

当数据库按照业务和数据维度拆分之后，我们尽量不要使用事务。因为当一个事务中同时更新不同的数据库时，需要使用二阶段提交，来协调所有数据库要么全部更新成功，要么全部更新失败。这个协调的成本会随着资源的扩展不断升高，最终达到无法承受的程度。

说完了存储层的扩展性，我们来看看业务层是如何做到易于扩展的。

#### 2.业务层的扩展性

我们一般会从三个维度考虑业务层的拆分方案，它们分别是：业务维度，重要性维度和请求来源维度。

首先，我们需要把相同业务的服务拆分成单独的业务池，比方说上面的社区系统中，我们可以按照业务的维度拆分成用户池、内容池、关系池、评论池、点赞池和搜索池。

每个业务依赖独自的数据库资源，不会依赖其它业务的数据库资源。这样当某一个业务的接口成为瓶颈时，我们只需要扩展业务的池子，以及确认上下游的依赖方就可以了，这样就大大减少了扩容的复杂度。

![](https://static001.geekbang.org/resource/image/a6/b5/a62e9add7797fc8e55c06fa8a21065b5.jpg?wh=1142%2A664)

除此之外，我们还可以根据业务接口的重要程度，把业务分为核心池和非核心池。打个比方，就关系池而言，关注、取消关注接口相对重要一些，可以放在核心池里面；拉黑和取消拉黑的操作就相对不那么重要，可以放在非核心池里面。这样，我们可以优先保证核心池的性能，当整体流量上升时优先扩容核心池，降级部分非核心池的接口，从而保证整体系统的稳定性。

![](https://static001.geekbang.org/resource/image/ce/28/ce6e856238d8af7059c44b3a47eced28.jpg?wh=1142%2A499)

最后，你还可以根据接入客户端类型的不同做业务池的拆分。比如说，服务于客户端接口的业务可以定义为外网池，服务于小程序或者HTML5页面的业务可以定义为H5池，服务于内部其它部门的业务可以定义为内网池，等等。

## 课程小结

本节课我带你了解了提升系统扩展性的复杂度以及系统拆分的思路。拆分看起来比较简单，可是什么时候做拆分，如何做拆分还是有很多细节考虑的。

未做拆分的系统虽然可扩展性不强，但是却足够简单，无论是系统开发还是运行维护都不需要投入很大的精力。拆分之后，需求开发需要横跨多个系统多个小团队，排查问题也需要涉及多个系统，运行维护上，可能每个子系统都需要有专人来负责，对于团队是一个比较大的考验。这个考验是我们必须要经历的一个大坎，需要我们做好准备。

## 一课一思

在今天的课程中，我们谈到了传统关系型数据库的可扩展性是很差的，那么在你看来，常见的NoSQL数据库是如何解决扩展性的问题呢？欢迎在留言区和我一起讨论。

最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。
<div><strong>精选留言（15）</strong></div><ul>
<li><span>mgxian</span> 👍（58） 💬（5）<p>memcached 官方没有提供集群特性，一般第三方会使用一致性哈希算法来进行负载均衡实现集群扩展。
redis 官方的集群选择把数据根据key来哈希分配到固定数量的 slot 上，然后把 slot 再分配到具体的redis实例上来实现集群，当需要扩展时，只需要把 slot 分配一些到新加入的 redis 实例即可。这种多加一层来实现集群扩展的方式，类似于我们数据库分表时使用的索引表。</p>2019-09-27</li><br/><li><span>coffee</span> 👍（30） 💬（1）<p>关系型数据库是强schema约束，并且支持事务，所以扩展性相对较差。
NOSQL一般都不是强schema约束的，所以可扩展性比关系型数据库要好。</p>2019-09-27</li><br/><li><span>YY</span> 👍（16） 💬（3）<p>数据库拆分后，但是各个库还是有相互依赖的，比如关系池，内容池都会依赖用户池，这种相互依赖的关系怎么解决？</p>2019-12-17</li><br/><li><span>xu晓晨</span> 👍（13） 💬（6）<p>redis扩展主要两方面。主备方案以及集群方案。
主备的话可以用redis的sentinel（哨兵）方案主要是解决redis主节点故障后的自动切换。它负责持续监控主从节点的健康，当主节点挂掉时，自动选择一个最优的从节点切换为主节点。
集群方案的话主流的是两种 一种是codis另一种是redis官方提供的cluster。</p>2019-09-30</li><br/><li><span>A.Windy</span> 👍（13） 💬（1）<p>这不就是微服务嘛😄</p>2019-09-29</li><br/><li><span>hailong</span> 👍（8） 💬（4）<p>为了一个服务就要一个库？ 本次课程举的例子一个数据库分不同的表就行了，没懂分库啥意思</p>2019-10-09</li><br/><li><span>吃饭饭</span> 👍（4） 💬（2）<p>两个问题：
1）尽量不适用事务，这里是不是需要使用分布式事务？类似于使用消息中间件等？
2）图示中的`池`指的是单个的微服务吗？我第一次听说这个概念，希望老师帮忙回答：）</p>2019-10-08</li><br/><li><span>helloworld</span> 👍（4） 💬（1）<p>系统的易扩展之从存储和业务拆分来考虑。业务拆分是容易理解的，专人专事；从存储角度来考虑我想是因为所有应用的功能的最终的结果都是把一些结果存储起来，于是存储就是重点，是重点就必然引起量大，量大了必然成瓶颈。打卡04。</p>2019-10-07</li><br/><li><span>StarKing</span> 👍（4） 💬（1）<p>预测未来的数据库一定会综合ES+MONGODB的能力，直接选择库的模式就可以像NOSQL一样使用。</p>2019-10-02</li><br/><li><span>飞翔</span> 👍（4） 💬（6）<p>老师。不太理解什么是池？ 用户池 里是一台机器还是多台机器呀？</p>2019-09-27</li><br/><li><span>Sports</span> 👍（3） 💬（1）<p>看的是真过瘾，很有逻辑和条理性，不像一些课程要么都是曲高和寡的技术细节，要么都是泛泛白话</p>2020-01-17</li><br/><li><span>XD</span> 👍（3） 💬（5）<p>redis相关的书籍或者博客有推荐吗？前段时间刚看了一个分布式锁的文章，收获很大。</p>2019-11-01</li><br/><li><span>Hwan</span> 👍（2） 💬（1）<p>看评论说auto shard ，最近在看redis，redis通过哨兵做主从备份和主从迁移，通过集群做增加主节点和减少主节点的事情，基本可以做好自动扩容和缩容了，请问下关系型数据库里面有类似的吗，能够实现自动的扩容之类的，还是说必须需要人工来呢</p>2019-10-29</li><br/><li><span>醇梨子</span> 👍（2） 💬（1）<p>我们在实际生产环境中，线程池隔离及线程池设置大小的依据是什么？</p>2019-09-28</li><br/><li><span>王三好</span> 👍（1） 💬（1）<p>一直都是这么做的，没有系统整理过，业务池子拆分还可以根据，业务是否经常变化，经常变化的抽取出来</p>2020-04-17</li><br/>
</ul>